[{"title":"也谈MV*","date":"2017-08-23T03:00:25.000Z","path":"2017/08/23/也谈MV*/","text":"复杂的软件开发需要有合理的开发架构，从另一方面来说，这也是开发规范的一种。 MVC、MVP、MVVM源自于职能分化和规划的思想与目的…无论是哪种架构，其实都离不开view、model，区别在于控制流是怎么样的以及各部分之间的分工。 1. 从MVC说起MVC(Model–view–controller)是架构设计模式中的一种，它强制将业务数据与用户界面隔离，用控制器来管理逻辑和用户输入。 模型model: 保存数据，和后端交互同步应用数据或者校验数据视图view: 用户界面，是model的可视化表示，代表当前状态的视图。控制器controller: 业务逻辑，连通model与view, model的任何改变会应用到View中，view的操作会通过Controller应用到Model。 图1 controller接收指令从接收用户指令的角度讲MVC分为两种，view接收指令与controller接收指令（图1），实现上也可能两者并存。 图2 controller与view同时接收用户指令如图2为两者并存，hashChange相关事件直接由controller接收，用户点击等操作由view层接收。这种模式更为灵活，但是又不算有真正的controller，换句话说’fat views and thin controllers’。目前，采用这种模式的有backbone。backbone是一个小巧灵活的库，是个不错的工具，适合那些有一定Web基础，喜欢原生JS，自己去操作DOM（因为它没有DOM Binding），写一些框架、库、插件的童鞋。它的特点是灵活，并不全包。只是帮你实现一个MVC模式的框架，更多的还需要自己去实现。MVC缺点：model对外暴露了set和on方法，导致view层可以随意改变或监听Model中值的变化，随着项目越来越复杂，数据流动方式会越来越乱，某个庞大的Model中某个字段改变之后有可能触发无数个change事件，导致一连串的change被触发。2. 传说中的MVP-fat models and thin controllers 图3 MVP模式在MVP模式下，view与presenter，presenter与model之间均为双向通信。presenter将model于view完全隔离开来。具有如下特点：&gt; Passive View（被动视图）&gt; Supervising Controller3. MVVM 图4 MVP模式 MVVM assumes that changes in the ViewModel will be reflected in the view by a robust data-binding engine。MVVM基本上与 MVP 模式完全一致，但是它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel上，Angular、vue为典型代表。 4. 再来看Redux当你感觉自己熟练掌握react的state、props、各类生命周期的时候，再来看看redux，会觉得之前仿佛只会写onclick。看一下redux的三大原则： 1.单一数据源：一个应用永远只能有唯一数据源，而不是像传统MVC中那样有多个Model、Model间可以相互监听。2.状态是只读的：reducer的作用是根据当前的action对state进行迭代，并不是直接修改；3.状态修改由纯函数来完成：reducer为纯函数，输入确定-输出确定 redux的关键模块有：Reducer、Store、Actions（action creator+action）、Components,其实可以将Redux+react看做MVC的一种实现方式，只不过它强制要求了单向数据流。 图5 Redux与MVC Actions = Controller：在应用中用户触发某些行为时，我们需要dispatch一个action，进行相应的异步请求或业务逻辑处理；Reducer = Model：Reducer决定了当一个action触发时，是否要进行相应的数据更新Store = ???： Store在MVC中并没有严格的对应关系，它可以比作连接各个Reducer的模块；Components = Views： 进行渲染 Thanks to：1.Scaling Isomorphic Javascript Code2.谈谈MVC模式——阮一峰3.Thinking in Redux (when all you’ve known is MVC)","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/框架/"}]},{"title":"js中的类型判定","date":"2017-08-22T01:40:47.000Z","path":"2017/08/22/js中的类型判定/","text":"类型判定深拷贝或者日常开发中经常涉及到一些关于类型判定的场景，尤其是数组，我在这一小节，着重分析数组、null、NaN的判断方法。js有5种基本类型，分别为number、string、boolean、null、undefined。引用类型Object，数组属于引用类型中的一种。typeof 而方法返回的是字符串，有六种可能：”number”、”string”、”boolean”、”object”、”function”、”undefined”。1234567typeof 123 // numbertypeof '123' // stringtypeof undifined // undefinedtypeof true // booleantypeof null // objecttypeof [] // object Array类型判断数组类型的判断大致有三种： 1. constructor/instanceof12value instanceof Arrayvalue.constructor instanceof的其中一个问题在于，它假定只有一个全局环境。如果网页中包含不同的框架，则存在多个全局执行环境，从而有多个Array构造函数。 2. isArray()ECMAscript5提出了isArray，它可以解决instanceof存在的多环境问题，但是兼容性有限（IE9+）。 3. Object的toString方法Object中的toString方法是最受青睐的一种，可以用来进行各种类型的判定。1234function getType(arg) &#123; let typeStr = Object.prototype.toString.call(arg); return typeStr.replace(/\\[object|\\]|\\s/g, '');&#125;, 当然，没有万全的保障，这个也是有一定问题的。要保证你的环境下，Object.prototype.toString方法没有被重写。 NaN判断首先判断NaN之前，我们要知道它是个什么类型的，not a number但是它是——number类型。 1.isNaN()ECMAScript 2015/ES6 中定义了Number.isNaN()。isNaN()会首先尝试将这个参数转换为数值，然后才会对转换后的结果是否是NaN进行判断。因此，对于能被强制转换为有效的非NaN数值来说（ 值得一提的是，空字符串和布尔值会被强制转换为数值0或1），返回false值也许会让人感觉莫名其妙。比如说，空字符串就明显”不是数值“（not a number）。1234567891011// isNaN可以看做isNaN = function(value) &#123; Number.isNaN(Number(value));&#125;isNaN(NaN); // trueisNaN(undefined); // trueisNaN(&#123;&#125;); // trueisNaN(true); // falseisNaN(null); // falseisNaN(37); // false 2. x!==xNaN有个特点，和任何对比均不相等，就是我连自己都不认的这种特点，我们才能认出它。123isNaN = function (x) &#123; return x !== x;&#125; null判断利用!null = true，typeof null = ‘object’，null != 0;123isNull = function () &#123; return (!x &amp;&amp; typeof(x)!=\"undefined\" &amp;&amp; x!=0);&#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"简单问题反省","slug":"简单问题反省","permalink":"http://yoursite.com/tags/简单问题反省/"}]},{"title":"js中的深度拷贝","date":"2017-08-16T13:38:44.000Z","path":"2017/08/16/js中的深度拷贝/","text":"背景： javascript中，由于Object和Array这类引用类型的值存在，复制变量时若只是简单赋值，两个变量指向同一个堆变量，此时的赋值只是地址赋值。改变其中的一个对象，另外一个也会随之改变。因此，在开发时会有用到深拷贝的场景，例如react进行setState时。 浅拷贝浅拷贝如前文所说，拷贝原对象的实例，但是对其内部的引用类型值，拷贝的是其引用。1234567891011121314151617var obj1 = &#123;b:2&#125;;var obj2 = obj1; // 此时只拷贝了对象的地址console.log(o1===o2); // trueobj1.b = 3;console.log(obj1); // 输出&#123;b:3&#125;console.log(obj2); // 同样输出&#123;b:3&#125;var arr1 = [1,2,3];var arr2 = arr1;arr1 === arr2; // truearr2.push(4);console.log(arr2); // [1,2,3,4]console.log(arr1); // [1,2,3,4] jquery中$.extend({}, obj)，Array.prototype.slice()和Array.prototype.concat()返回对象或者数组的浅拷贝。example: 123456789var arr1 = ['iwtofly', &#123;age: 22&#125;];var arr2 = arr1.slice();console.log(o1 === o2); // falseconsole.log(o1[1] === o2[1]) // truearr2[1].age = 23;console.log(arr2[1].age); // 23console.log(arr1[1].age); // 23 浅拷贝实现方法之一， 下段实现中的shallowClone：123456789101112131415161718192021222324252627282930313233module.exports = &#123; /** * 获取类型 * @param &#123;object/array/undefined/null/number/string/...&#125; arg 待判断类型参数 * @return &#123;String&#125; 参数类型（首字母大写） */ getType: function(arg) &#123; let typeStr = Object.prototype.toString.call(arg); return typeStr.replace(/\\[object|\\]|\\s/g, ''); &#125;, /** * 浅拷贝--非递归 * @param &#123;[type]&#125; src 待拷贝的对象 * @return &#123;[type]&#125; 拷贝结果 */ shallowClone: function(src) &#123; if (!src &amp;&amp; typeof src !== 'object') &#123; console.log('it is not a object'); &#125; const type = this.getType(src); let target = type === 'Array' ? [] : &#123;&#125;; for (let key in src) &#123; if (src.hasOwnProperty(key)) &#123; target[key] = src[key]; &#125; &#125; return target; &#125;, ···&#125; 深拷贝最简单的深拷贝是利用序列化和反序列化：1var target = JSON.parse(JSON.stringify(obj)); 但是这种方法在序列化JavaScript对象时，所有函数和原型成员会被有意忽略，拷贝结果会丢失function、Date等类型。除此之外，按照上面浅拷贝实现的思路只需要进行递归即可实现深拷贝如下：12345678910111213141516171819202122232425262728293031323334353637383940module.exports = &#123; /** * 获取类型 * @param &#123;object/array/undefined/null/number/string/...&#125; arg 待判断类型参数 * @return &#123;String&#125; 参数类型（首字母大写） */ getType: function(arg) &#123; let typeStr = Object.prototype.toString.call(arg); return typeStr.replace(/\\[object|\\]|\\s/g, ''); &#125;, ··· /** * 深拷贝--递归 * @param &#123;[type]&#125; src 待拷贝的对象 * @return &#123;[type]&#125; 拷贝结果 */ deepClone: function(src) &#123; if (!src &amp;&amp; typeof src !== 'object') &#123; console.log('it is not a object'); &#125; const type = this.getType(src); let target = type === 'Array' ? [] : &#123;&#125;; for (let key in src) &#123; if (src.hasOwnProperty(key)) &#123; const subType = this.getType(src[key]); if (subType === 'Object' || subType === 'Array') &#123; // Object sub target[key] = this.deepClone(src[key]); &#125; else &#123; target[key] = src[key]; &#125; &#125; &#125; return target; &#125;&#125; 结果测试1234567891011121314let Clone = require('../clone.js');let o1 = ['iwtofly', &#123;age: 23&#125;, [1,2,3]];let shallow = Clone.shallowClone(o1);let deep = Clone.deepClone(o1);console.log(shallow);console.log(deep);console.log('shallow is equal to o1? ',shallow === o1);console.log('deep is equal to o1? ', deep === o1);console.log('shallow[1] is equal to o1[1]? ',shallow[1] === o1[1]);console.log('deep[1] is equal to o1[1]? ', deep[1] === o1[1]); 文件执行结果：123456[ 'iwtofly', &#123; age: 23 &#125;, [ 1, 2, 3 ] ][ 'iwtofly', &#123; age: 23 &#125;, [ 1, 2, 3 ] ]shallow is equal to o1? falsedeep is equal to o1? falseshallow[1] is equal to o1[1]? truedeep[1] is equal to o1[1]? false 注意 有时突然想到深拷贝第一反应只会想到要区分Object类型，却忘记Array类型也要在初始化target时进行区分 区分数组和其他类型有多种方法，我常用的是下面的第一个方法 Object的toString方法（Object.prototype.toString.call(obj)），再用正则去匹配，滤掉相同/公共的部分； object.constructor === Array, 数组的构造函数均为[Function: Array]，但是多个环境，例如iframe嵌入的页面进行交互时无法使用，因为两个环境下存在不同的构造函数。 for in会遍历出prototype中的属性 如果要求高的话，其实还需要单独判断Date、RegExp…类型——new Date(src.getDate())，new RegExp(src.valueOf())。 object.keys(),不会遍历原型链上的属性。 js类型判定专栏; 其他方法深拷贝详见：https://github.com/iwtofly/FE-tools/blob/master/jsUtil.js本方法实现：https://github.com/iwtofly/FE-tools/blob/master/clone.js","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"简单问题反省","slug":"简单问题反省","permalink":"http://yoursite.com/tags/简单问题反省/"}]},{"title":"日常CSS备忘","date":"2017-08-16T11:38:25.000Z","path":"2017/08/16/常忘CSS梳理备份/","text":"由于经常使用框架配套组件库，CSS技巧会生疏，今天转正面试被问到transiton都感觉很尴尬，因此在此梳理记录。 1. 内容超过一定宽度时设置…1234567&#123; width: 27em; white-space: nowrap; text-overflow: ellipsis; -o-text-overflow: ellipsis; overflow: hidden;&#125; 内容超出所设置宽度时会出现’…’ 2. CSS3的transition过渡属性有人说transition、transform、animation分别对应于过渡、变换、动画。 transition的作用是平滑的改变CSS的值，transition有以下几个属性： transition-property:指定过渡的性质，比如transition-property:backgrond transition-duration:过渡持续时间 transition-delay: 延迟过渡时延 transition-timing-function: 指定过渡类型,ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier example:12345678910111213.mydiv&#123; width: 100px; height: 100px; background: blue; transition: all 2s 0.5s ease; -webkit-transition: all 2s 0.5s ease; -moz-transition: all 2s 0.5s ease; -o-transition: all 2s 0.5s ease;&#125;.mydiv:hover&#123; width: 300px; background: pink;&#125; all为width和background均参与变换，最终效果为，鼠标hover之后延迟0.5s颜色渐变、宽度渐变。参与transition的属性有非常多，除了以上两种还有margin、color、border等等，还有transform相关。 参考：https://www.w3.org/TR/css3-transitions/#animatable-properties- 3. CSS3-transform 变换transform用于调整scale、rotate、translate等等。例如在垂直水平居中时常用1transform: translate(-50%, -50%); 此外transform经常和transition一起应用，营造比较丰富的动画。transform作用于block元素！！example:123456789101112131415161718.trans-div &#123; display: block; line-height: 100px; width: 100px; background: #beceeb; margin:30px auto; text-align:center; -webkit-transition:all 2s ease-in-out; -moz-transition:all 2s ease-in-out; -o-transition:all 2s ease-in-out; transition:all 2s ease-in-out;&#125;.trans-div:hover &#123; -webkit-transform:rotate(720deg) scale(2,2); -moz-transform:rotate(720deg) scale(2,2); -o-transform:rotate(720deg) scale(2,2); transform:rotate(720deg) scale(2,2);&#125; 1&lt;a class=\"trans-div\"&gt;hover me&lt;/a&gt; 效果：由内向外旋转同时放大。 4. CSS3-animation 动画animation需要配合keyframes使用，定义动画的关键帧。之后用animation规定使用动画的 frame名称、持续时间、ease等效果。12345678910111213141516171819div &#123; width:100px; height:100px; background:red; position:relative; animation:mymove 5s infinite; -webkit-animation:mymove 5s infinite; /*Safari and Chrome*/&#125;@keyframes mymove&#123; from &#123;left:0px;&#125; to &#123;left:200px;&#125;&#125;@-webkit-keyframes mymove /*Safari and Chrome*/&#123; from &#123;left:0px;&#125; to &#123;left:200px;&#125;&#125; 也可以分开定义animation的各个属性，分别为： animation-name 名称animation-duration 持续时间animation-timing-function 动画的速度曲线animation-delay 延时animation-iteration-count 应该播放的次数（infinite是无限循环）animation-direction 动画方向 参考：http://lin-xi.github.io/css3-animation 5. 关于单位vh、vw、vm与calc vw：是相对于视窗的宽度，100vw为整个宽度vh：是相对于视窗高度，100vh为整个视窗高度vm：取决于视窗高宽小的一方 vw、vh分别对应于浏览器的window.innerWidth/window.innerHeight这一项； calc不能计算诸如 calc(100vh-20px)的公式是个错误的说法！！！calc的优势就在于可以计算mixing units；一直以来以为calc不能计算vh-px，结果发现是’-‘运算符两边没有空格导致不生效。心累。 参考：https://www.smashingmagazine.com/2015/12/getting-started-css-calc-techniques/ 6. 对:after或者:before伪元素设置image大小相关知识点：background-image相关项目中小需求是:**切换导航时tab前出现定位icon，使用:before，关键点如下： 123456789101112.tab:before &#123; content: ''; display: inline-block; font-size: 0; background-image: url('urlbalabal'); background-repeat: no-repeat; background-size: contain; // 此处选择了contain margin-right: 3px; margin-bottom: -4px; height: 18px; width: 12px;&#125; content本身可以设置url(‘imgurl’)，但是这样无法设置图片大小。因此要采用background-image。12345background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | containbackgroud-size:contain; //把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。backgroud-size:cover; // 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。// 背景图像的某些部分也许无法显示在背景定位区域中。 容器与背景图长度比:150/100=1.5宽度比:60/50=1.2cover 取大,所以就按照 长度比 1.5 (等比缩放背景图片)contain 取小,所以就按宽度比 1.2 (等比缩放背景图片) 参考： https://stackoverflow.com/questions/8977957/can-i-change-the-height-of-an-image-in-css-before-after-pseudo-elements http://yijiebuyi.com/blog/260c099f3462623f6c1e4425e3bd8664.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"简单问题反省","slug":"简单问题反省","permalink":"http://yoursite.com/tags/简单问题反省/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"ES6 class继承与ES5继承","date":"2017-08-13T07:07:35.000Z","path":"2017/08/13/ES6-class继承与ES5继承/","text":"JS中的继承是一个比较麻烦的问题，最近在看js设计模式，前几章涉及到许多继承相关的知识点，例如prototype、constructor、__proto__、构造函数，实例和原型。因此在此进行思考和梳理。 es5 es6继承ES6 CLASS","tags":[]},{"title":"Promise实现原理","date":"2017-08-02T13:49:08.000Z","path":"2017/08/02/Promise实现原理/","text":"","tags":[]},{"title":"lazyLoad简单实现+Flicker图片获取","date":"2017-03-20T14:31:31.000Z","path":"2017/03/20/lazyLoad简单实现-Flicker图片获取/","text":"lazyLoad（懒加载），是对网页进行优化的一种方案，可以适当提升用户体验，它的作用： 网站性能优化，提高用户体验 页面如果有很多图片的时候，当你滚动到相应的行时，当前行的图片才即时加载的，这样子的话页面在打开只加可视区域的图片，而其它隐藏的图片则不加载。 简易DEMO链接（图片请求自Flicker）：http://iwtofly.cn/demos/lazyLoad/index.html lazyload的难点在如何在适当的时候加载用户需要的资源(这里用户需要的资源指该资源呈现在浏览器可视区域)。因此我们需要知道几点信息来确定目标是否已呈现在客户区,其中包括： 未完待续…","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"React中createClass、PureComponent、Component的不同","date":"2017-03-07T09:36:02.000Z","path":"2017/03/07/React中createClass、pureComponent、Component的不同/","text":"16年6月开始使用React，至今写法上发生了很大的变化，不过也可能是一开始接触的太low了。我使用过的创建react组件的方式大致有三种形式。 var Name = React.createClass class Name extends Component class Name extends PureComponent 友情提示：后两种需要babel转码 那么，前两种方式有哪些区别呢？首先，从createClass到class extends的改变是基于ES6的语法糖——class, 很类似于php等语言中的语法。本质上来讲，他们之间的差别不大，但是掌握他们的不同可以让我们更好的选择适合的方案。我们简单来看一下两种方法下构成的代码： createClass方式123456789101112131415161718192021222324252627282930313233import React, &#123;PureComponent&#125; from 'react';const Example = React.createClass(&#123; propTypes: &#123; title: React.PropTypes.string.isRequired &#125;, mixins: [SomeMixin], // ES6不支持 getDefaultProps() &#123; return &#123; title: 'I am title' &#125;; &#125;, getInitialState() &#123; return &#123; name: 'world' &#125; &#125;, handleClick() &#123; console.log('clicked!'); &#125;, render() &#123; return( &lt;div&gt; &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt; hello, &#123;this.state.name&#125; &lt;/div&gt; ) &#125;&#125;);export default Example; class extends方式123456789101112131415161718192021222324252627282930313233343536373839import React from 'react';class Example extends React.Component &#123; constructor(props) &#123; super(props); // super之后才能使用this this.state = &#123; name: 'world' &#125; // 重要！！ this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; console.log('clicked!'); &#125; render() &#123; const &#123;name&#125; = this.state; return( &lt;div&gt; &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt; hello, &#123;name&#125; &lt;/div&gt; ) &#125;&#125;;// 验证类型 =&gt; 对应 propTypes: &#123;&#125;Example.propsTypes = &#123; title: React.PropTypes.string.isRequired,&#125;// 设置默认属性值 =&gt; 对应 getDefaultProps() &#123;&#125;Example.defaultProps = &#123; title: 'I am title'&#125;;export default Example; 1. 语法区别敲黑板， 注意逗号 ，切忌自嗨。class extends的语法形式引入了 constructor ,方便我们调用 super() 函数来为Component传递属性。还可以传递context上下文，实现依赖注入， 这部分，下次再写 。 2. state初始化在createClass中，我们创建了一个getInitialState返回创建的state对象。在class extends方式中，我们在constructor中调用了super()之后，访问this，创建this.state，初始化声明状态。 3. this的区别（重要）createClass时，React会自动帮助我们处理 this 指向。但是，在class extends的方式中，对button进行事件绑定时，需要注意，此时this默认并没有绑定到React实例上，因此需要做相应的处理：1&lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;/button&gt; 或者如上例所示，在constructor中中调用了super()之后，改变this.handleClick执行的上下文。 那么PureComponent与直接使用Component又有什么不同呢？ PureComponent与Component的不同点在没有使用Redux的情况下，我们需要进行优化减少不必要的render时，经常需要手写shouldComponentUpdate，复杂的情况下要进行一系列深比较等。当然，也可以配合Immutable.js实现。而PureComponent的方式创建组件时，react会帮助我们进行一次 ‘浅比较’’ ，一定程度上来减少不必要的render。这里，我给浅比较加上了一个引号。 我的测试代码如下，father.js为父组件，sub.js为子组件 father.js12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123;PureComponent, Component&#125; from 'react';import Sub from './sub.js';// export default class Father extends PureComponent &#123;export default class Father extends Component &#123; constructor(props, context) &#123; super(props, context); this.state = &#123; items: [], test: undefined &#125; &#125; componentDidMount() &#123; console.log(\"father componentDidMount\"); &#125; handleClick() &#123; this.setState(&#123;items: this.state.items.concat(['new-item'])&#125;); // this.setState(prevState =&gt; (&#123; // items: prevState.items.concat(['new-item']) // &#125;)) &#125; handleClickFather() &#123; this.setState(&#123; test: '123' &#125;) &#125; render() &#123; console.log('Father --render'); return( &lt;div&gt; It is the father! &lt;button onClick=&#123;this.handleClickFather.bind(this)&#125;&gt;father Button&lt;/button&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;sub Button&lt;/button&gt; &lt;Sub items=&#123;this.state.items&#125;/&gt; &lt;/div&gt; ) &#125;&#125; sub.js1234567891011121314151617181920212223242526import React, &#123;PureComponent, Component&#125; from 'react';// export default class Sub extends PureComponent &#123;export default class Sub extends Component &#123; constructor(props, context) &#123; super(props, context); console.log('context in constructor',context); this.state = &#123; title: this.context.title &#125; &#125; componentDidMount()&#123; console.log(\"sub componentDidMount\"); &#125; render() &#123; console.log('sub --render'); return( &lt;div&gt;it is my sub, the title get from apptestpage is ---- &#123;this.state.title&#125;&lt;/div&gt; ) &#125;&#125;Sub.contextTypes = &#123; title: React.PropTypes.string&#125; 可以看出，father.js调用了sub.js,我们在father.js中设定了两个button，第一个’father button’绑定事件将会更改father组件中的state——test，这个test并未作为参数传入sub。另一个button，sub button绑定的事件将会改变items,并且sub组件接收该props。father.js与sub.js均使用 class Sub extends Component 时，点击两个按钮，发现控制台均打印：12Father --rendersub --render 也就是说，test的改变，引起了sub不必要的一次render。 之后，再使用 class Sub extends Component 创建组件，点击father button，控制台打印：1Father --render 点击sub button,控制台打印12Father --rendersub --render 此时，才是我们想要的结果。 但是 ，使用PureComponent，需要注意的是，我此时使用的方法是数组的concat，concat有一个特点是会新创建一个数组对象，假如使用push方法，就会出现sub.js不进行render的情况。也就是说，PureComponent比较的是简单类型的值，或者对象的地址，这些内容都有一个特点，应该是存在栈当中的（恩，才疏学浅，我是这么骗自己的。如果错了，不要当真）。因此，在大多数情况下，我们还是需要手写shouldComponentUpdate滴。恩，当然，还可以移步redux。 好了，不喜欢写文档的我，写到这里我已经用尽洪荒之力了。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"Reactjs","slug":"Reactjs","permalink":"http://yoursite.com/tags/Reactjs/"}]},{"title":"JS数组去重","date":"2017-02-25T08:44:54.000Z","path":"2017/02/25/JS数组去重/","text":"注意 ：需要注意包含NaN类型数据的去重 使用Array.prototype.indexOf(), indexOf使用的是严格等 ‘===’ 思路1 =&gt; arr.filter()12345function unique(arr) &#123; return arr.filter(function(item, index) &#123; return arr.indexOf(item) === index; &#125;)&#125; 思路2 =&gt; arr.forEach()123456789function unique(arr) &#123; var ret = []; arr.forEach(function(item) &#123; if (ret.indexOf(item) === -1) &#123; ret.push(item); &#125; &#125;); return ret;&#125; 思路3 =&gt; es2015新增方法includes 解决NaN123456789function unique(arr) &#123; var ret = []; arr.forEach(function(item) &#123; if (!ret.includes(item)) &#123; ret.push(item); &#125; &#125;); return ret;&#125; 思路4 =&gt; 借助set，map等ES6新增类型https://www.toobug.net/article/array_unique_in_javascript.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"小白眼中的跨域","date":"2017-02-15T13:02:20.000Z","path":"2017/02/15/小白眼中的跨域/","text":"跨域，这个纠结好久的问题，最近终于有些思路了。仿佛预见了自己将要不是哪个懒得只知道用cors中间件的小白啦！ 什么是跨域我们来看一下什么是跨域以及同源策略： 通过XHR实现Ajax通信的的主要限制，来源于跨域安全策略。所谓同源是指，域名，协议，端口相同。默认情况下，XHR对象只能访问与包含它的页面位于同一个域的资源。这种安全策略可以预防某些恶意行为。简单来说，形如a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。 跨域的几种情况下表所示： URL1 URL2 说明 通信否 http://www.a.com/a.js http://www.a.com/b.js 同一域名下 可 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名不同文件夹 可 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名不同端口 否 http://www.a.com/a.js https://www.a.com/b.js 同一域名不同协议 否 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 否 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 否 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 否（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 否 其中，如果是协议和端口造成的跨域问题前端是无能为力的；而且，在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。 如何解决跨域问题跨域问题的解决办法有很多种,大致可以分为两类： 一类是Hack，比如通过title、navigation、script等对象传递信息， JSONP 就是一种Hack方式; 另一类是HTML5支持，其中一种是 Access-Control-Allow-Origin 响应头，一个是 window.postMessage ; 1. JSONP 实现原理：虽然我们不能直接请求异源上的资源，但是在js中如img，script标签却是可以得到其他服务器上的资源的，那么我们就可以通过这样的方式将一段js代码间接地从外部引入。通过script标签向目标源发起一个GET请求，服务器根据请求的参数返回包含js的代码。 JSONP是JSON with Padding的简写，是一个非官方协议，她允许在服务端集成Script Tags返回客户端，通过javascript callback的形式实现跨域访问（注：简单实现形式是这样）。 缺点：JSONP只能实现GET请求。随着现在RESTful的兴起，JSONP显得力不从心了。因为，RESTful不仅有GET，还存在POST、PUT、PATCH、DELETE等等。 下面为index.html的代码：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jsonp test&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; var url = 'ticker.js'; function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute('src', src); document.body.appendChild(script); &#125; function callBack(data) &#123; console.log(data); &#125; window.onload = function() &#123; addScriptTag(url); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其中，ticker.js中的内容如下：123456callBack( &#123; name:'iwtofly', job: 'FE' &#125;) 结果显示如下： 此外还有很多好玩的地方可以小探索一下，例如google、Flickr等等都提供了JSONP的回调接口，笔者不才最近正在小玩了下Flickr，等稍有成果之后再做呈现。 2. iframe + domain原理 —— 形如http://a.com/video 与 http://b.a.com/video、http://c.a.com/video 这种 主域相同，子域不同的情况，可以通过设置document.domain让它们同域。限制 —— 同域document提供的是页面间的相互操作，需要载入iframe页面(即，只能通过页面嵌套的方式) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.domain用来得到当前网页的域名，给document.domain属性赋值是有限制的 —— 只能赋成当前的域名或者基础域名。http://b.a.com/ 为当前域名，http://a.com/ 为基础域名。因此，利用document.domain实现跨域前提条件为，这两个域名必须属于同一个基础域名而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。12345678910// 当前为http://iwtofly.cn/videovar ifr = document.createElement('iframe');ifr.src = 'http://www.iwtofly.cn/video'; ifr.onload = function()&#123; var ifrdoc = ifr.contentDocument || ifr.contentWindow.document; ifrdoc.getElementsById(\"foo\").innerHTML);&#125;;ifr.style.display = 'none';document.body.appendChild(ifr); 假设上述代码所在的URL为http://iwtofly.cn/video ，它对http://www.iwtofly.cn/video 的DOM访问要求后者将document.domain往上设置一级:1document.domain = iwtofly.cn; document.domain 只能从子域设置到主域，往下设置以及往其他域名设置都是不允许的 3. cors CORS（Cross Origin Resource Sharing, 跨源资源共享）是W3C的一个工作草案，定义了在必须访问跨源资源时浏览器与服务器应该如何进行沟通。其背后的思想，就是定义HTTP头部让浏览器与服务器进行沟通，从而决定请求或相应的成功与否，以便服务器根据这个头部信息来决定是否给予相应。 Origin头部示例：1Origin: http://iwtofly.cn 如果服务器认为这个来源的请求是可以接受的，就在Access-Control-Allow-Origin头部中回发相同的源信息，’*’代表允许一切来源的请求，一般设置为公共资源。示例：1Access-Control-Allow-Origin: http://iwtofly.cn 笔者用过这方面的工具有nodejs cors中间件。cors中间件在使用前需要安装cors模块：1$ npm install cors --save 然后，在 index.js 内添加中间件 app.use(cors());1234567891011121314151617181920var express = require('express');var app = express();var cors =require('cors');app.use(cors()); // 作用于全局的请求app.get('/table',function (req, res) &#123; res.send(data);&#125;)// 只用于'/table'的GET的写法// app.get('/table', cors(), function (req, res) &#123;// res.send(data);// &#125;);var server = app.listen(8988, function () &#123; var host = server.address().address; var port = server.address().port; console.log('back server: http://%s:%s', host, port);&#125;) 只有使用 cors()中间件才会释放出我们 Api 的访问权限。最好是控制哪些客户端可以进行连接，哪些方法可以使用。最主要的是，必须要在请求的时候加入到头部。在我们这个例子中仅需要设置三个属性： orgin（访问域）、method（访问方法）、alloweHeaders（请求头）。12345678910111213141516171819var express = require('express'); var cors = require('cors'); var app = express();app.use(cors(&#123; origin: ['http://localhost:3001'], methods: ['GET', 'POST'], alloweHeaders: ['Conten-Type', 'Authorization']&#125;));app.get('/', function(req, res) &#123; res.json(&#123;status: 'My Api is alive!'&#125;);&#125;);app.listen(3000, function() &#123; console.log('My Api is running...');&#125;);module.exports = app; 4. 中间层代理跨域问题的核心是不同源访问，因此，如果我们转换为同源请求，就不存在这个问题啦。通过搭建中间层，可以是java，也可以是node.js，通过将服务端的请求进行转发，换句话说，就是dispatcher了一层，那么前端请求的地址，就被转发了，所以很好的解决跨域问题。缺点：如果对性能有考量的产品，就需要慎重选择这个方案，因为多了一层中间转发，不管是网络开销，还是性能负载都是有一定的影响。 做了一个小测试，假设以下为server2.js,我们真正要请求的后端，运行在3002端口：1234567891011121314/** * 中间层跨域中的：server后端 */var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.json(&#123; name: 'iwtofly', job: 'FE' &#125;)&#125;);app.listen(3002);console.log('Express started on 127.0.0.1:3002'); 前端资源位于不同的域 ，但又想要对http://127.0.0.1:3002 的内容进行请求，我们可以搭建一个中间层，来转发请求。对于前端来说是对中间层进行了请求。中间层为server.js代码如下，利用了express + superagent：12345678910111213141516171819/** * 中间层跨域中的：中间层 */var express = require('express');var app = express();app.get('/', function (req, res) &#123; // 使用了superagent来发起请求 var superagent = require('superagent'); // 查询本机ip，这里需要根据实际情况选择get还是post var sreq = superagent.get('http://127.0.0.1:3002/'); sreq.pipe(res); sreq.on('end', function()&#123; console.log('done'); &#125;);&#125;);app.listen(3001);console.log('Express started on 127.0.0.1:3001'); 启动中间层，在浏览器中输入http://127.0.0.1:3001 即可看到返回的正确内容。 以上代码不借助superagent的实现方法如下：12345678910111213141516171819202122var http = require('http');// 创建http服务var app = http.createServer(function (req, res) &#123; // 查询本机ip var sreq = http.request(&#123; host: 'sneezryworks.sinaapp.com', // 目标主机 path: '/ip.php', // 目标路径 method: req.method // 请求方式 &#125;, function(sres)&#123; sres.pipe(res); sres.on('end', function()&#123; console.log('done'); &#125;); &#125;); if (/POST|PUT/i.test(req.method)) &#123; req.pipe(sreq); &#125; else &#123; sreq.end(); &#125;&#125;);app.listen(3001);console.log('Express started on 127.0.0.1:3001'); 5. nginx反向代理利用nginx路由重写，example like this:1234location ^~/proxy/html/&#123; rewrite ^/proxy/html/(.*)$ /$1 break; proxy_pass http://www.b.com/;&#125; ^~/proxy/html/匹配任何以 /proxy/html/开头的地址。 6. window.postMessagepostMessage接收两个参数，一个是想要发送的信息，第二个是要发送至的origin。在接收端，需要监听message事件，并且制定事件源。测试如下： 打开https://www.baidu.com ，开发者模式下，在控制台输入：123window.addEventListener('message','http://iwtofly.cn',function(event) &#123; console.log(event.data);&#125;); 打开http://iwtofly.cn ，开发者模式下，在控制台输入：12var win = window.open('https://www.baidu.com');win.postMessage('Hello, I am iwtofly', 'https://www.baidu.com'); 可以看到，在百度首页的控制台打印出接收到的信息。关于postMessage详细信息，见 https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage 。 参考：https://segmentfault.com/a/1190000000718840http://harttle.com/2015/10/10/cross-origin.htmlhttp://www.cnblogs.com/rainman/archive/2011/02/20/1959325.htmlJSONP：http://www.cnblogs.com/chopper/archive/2012/03/24/2403945.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]}]