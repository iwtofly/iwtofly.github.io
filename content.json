[{"title":"JS数组去重","date":"2017-02-25T08:44:54.000Z","path":"2017/02/25/JS数组去重/","text":"注意 ：需要注意包含NaN类型数据的去重 使用Array.prototype.indexOf(), indexOf使用的是严格等 ‘===’ 思路1 =&gt; arr.filter()12345function unique(arr) &#123; return arr.filter(function(item, index) &#123; return arr.indexOf(item) === index; &#125;)&#125; 思路2 =&gt; arr.forEach()123456789function unique(arr) &#123; var ret = []; arr.forEach(function(item) &#123; if (ret.indexOf(item) === -1) &#123; ret.push(item); &#125; &#125;); return ret;&#125; 思路3 =&gt; es2015新增方法includes 解决NaN123456789function unique(arr) &#123; var ret = []; arr.forEach(function(item) &#123; if (!ret.includes(item)) &#123; ret.push(item); &#125; &#125;); return ret;&#125; https://www.toobug.net/article/array_unique_in_javascript.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"小白眼中的跨域","date":"2017-02-15T13:02:20.000Z","path":"2017/02/15/小白眼中的跨域/","text":"跨域，这个纠结小白好久的问题，今天终于有些思路了。仿佛遇见了自己将要不是哪个懒得只知道用cors中间件的小白啦（哈哈，收–严肃脸）！ 什么是跨域我们来看一下什么是跨域以及同源策略： 通过XHR实现Ajax通信的的主要限制，来源于跨域安全策略。所谓同源是指，域名，协议，端口相同。默认情况下，XHR对象只能访问与包含它的页面位于同一个域的资源。这种安全策略可以预防某些恶意行为。简单来说，形如a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。 跨域的几种情况下表所示： URL1 URL2 说明 通信否 http://www.a.com/a.js http://www.a.com/b.js 同一域名下 可 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名不同文件夹 可 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名不同端口 否 http://www.a.com/a.js https://www.a.com/b.js 同一域名不同协议 否 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 否 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 否 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 否（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 否 其中，如果是协议和端口造成的跨域问题前端是无能为力的；而且，在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。 如何解决跨域问题跨域问题的解决办法有很多种,大致可以分为两类： 一类是Hack，比如通过title、navigation、script等对象传递信息， JSONP 就是一种Hack方式; 另一类是HTML5支持，其中一种是 Access-Control-Allow-Origin 响应头，一个是 window.postMessage ; 1. JSONP 实现原理：虽然我们不能直接请求异源上的资源，但是在js中如img，script标签却是可以得到其他服务器上的资源的，那么我们就可以通过这样的方式将一段js代码间接地从外部引入。通过script标签向目标源发起一个GET请求，服务器根据请求的参数返回包含js的代码。 JSONP是JSON with Padding的简写，是一个非官方协议，她允许在服务端集成Script Tags返回客户端，通过javascript callback的形式实现跨域访问（注：简单实现形式是这样）。 缺点：JSONP只能实现GET请求。随着现在RESTful的兴起，JSONP显得力不从心了。因为，RESTful不仅有GET，还存在POST、PUT、PATCH、DELETE等等。 下面为index.html的代码：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jsonp test&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; var url = 'ticker.js'; function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute('src', src); document.body.appendChild(script); &#125; function callBack(data) &#123; console.log(data); &#125; window.onload = function() &#123; addScriptTag(url); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其中，ticker.js中的内容如下：123456callBack( &#123; name:'iwtofly', job: 'FE' &#125;) 结果显示如下： 此外还有很多好玩的地方可以小探索一下，例如google、Flickr等等都提供了JSONP的回调接口，笔者不才最近正在小玩了下Flickr，等稍有成果之后再做呈现。 2. iframe3. domain原理 —— 形如http://a.com/video 与 http://b.a.com/video、http://c.a.com/video 这种 主域相同，子域不同的情况，可以通过设置document.domain让它们同域。限制 —— 同域document提供的是页面间的相互操作，需要载入iframe页面(即，只能通过页面嵌套的方式) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.domain用来得到当前网页的域名，给document.domain属性赋值是有限制的 —— 只能赋成当前的域名或者基础域名。http://b.a.com/ 为当前域名，http://a.com/ 为基础域名。因此，利用document.domain实现跨域前提条件为，这两个域名必须属于同一个基础域名而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。12345678910// 当前为http://iwtofly.cn/videovar ifr = document.createElement('iframe');ifr.src = 'http://www.iwtofly.cn/video'; ifr.onload = function()&#123; var ifrdoc = ifr.contentDocument || ifr.contentWindow.document; ifrdoc.getElementsById(\"foo\").innerHTML);&#125;;ifr.style.display = 'none';document.body.appendChild(ifr); 假设上述代码所在的URL为http://iwtofly.cn/video ，它对http://www.iwtofly.cn/video 的DOM访问要求后者将document.domain往上设置一级:1document.domain = iwtofly.cn; document.domain 只能从子域设置到主域，往下设置以及往其他域名设置都是不允许的 4. cors CORS（Cross Origin Resource Sharing, 跨源资源共享）是W3C的一个工作草案，定义了在必须访问跨源资源时浏览器与服务器应该如何进行沟通。其背后的思想，就是定义HTTP头部让浏览器与服务器进行沟通，从而决定请求或相应的成功与否，以便服务器根据这个头部信息来决定是否给予相应。 Origin头部示例：1Origin: http://iwtofly.cn 如果服务器认为这个来源的请求是可以接受的，就在Access-Control-Allow-Origin头部中回发相同的源信息，’*’代表允许一切来源的请求，一般设置为公共资源。示例：1Access-Control-Allow-Origin: http://iwtofly.cn 笔者用过这方面的工具有nodejs cors中间件。cors中间件在使用前需要安装cors模块：1$ npm install cors --save 然后，在 index.js 内添加中间件 app.use(cors());1234567891011121314151617181920var express = require('express');var app = express();var cors =require('cors');app.use(cors()); // 作用于全局的请求app.get('/table',function (req, res) &#123; res.send(data);&#125;)// 只用于'/table'的GET的写法// app.get('/table', cors(), function (req, res) &#123;// res.send(data);// &#125;);var server = app.listen(8988, function () &#123; var host = server.address().address; var port = server.address().port; console.log('back server: http://%s:%s', host, port);&#125;) 只有使用 cors()中间件才会释放出我们 Api 的访问权限。最好是控制哪些客户端可以进行连接，哪些方法可以使用。最主要的是，必须要在请求的时候加入到头部。在我们这个例子中仅需要设置三个属性： orgin（访问域）、method（访问方法）、alloweHeaders（请求头）。12345678910111213141516171819var express = require('express'); var cors = require('cors'); var app = express();app.use(cors(&#123; origin: ['http://localhost:3001'], methods: ['GET', 'POST'], alloweHeaders: ['Conten-Type', 'Authorization']&#125;));app.get('/', function(req, res) &#123; res.json(&#123;status: 'My Api is alive!'&#125;);&#125;);app.listen(3000, function() &#123; console.log('My Api is running...');&#125;);module.exports = app; 5. 中间层代理跨域问题的核心是不同源访问，因此，如果我们转换为同源请求，就不存在这个问题啦。通过搭建中间层，可以是java，也可以是node.js，通过将服务端的请求进行转发，换句话说，就是dispatcher了一层，那么前端请求的地址，就被转发了，所以很好的解决跨域问题。缺点：如果对性能有考量的产品，就需要慎重选择这个方案，因为多了一层中间转发，不管是网络开销，还是性能负载都是有一定的影响。 做了一个小测试，假设以下为server2.js,我们真正要请求的后端，运行在3002端口：1234567891011121314/** * 中间层跨域中的：server后端 */var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.json(&#123; name: 'iwtofly', job: 'FE' &#125;)&#125;);app.listen(3002);console.log('Express started on 127.0.0.1:3002'); 前端资源位于不同的域 ，但又想要对http://127.0.0.1:3002 的内容进行请求，我们可以搭建一个中间层，来转发请求。对于前端来说是对中间层进行了请求。中间层为server.js代码如下，利用了express + superagent：12345678910111213141516171819/** * 中间层跨域中的：中间层 */var express = require('express');var app = express();app.get('/', function (req, res) &#123; // 使用了superagent来发起请求 var superagent = require('superagent'); // 查询本机ip，这里需要根据实际情况选择get还是post var sreq = superagent.get('http://127.0.0.1:3002/'); sreq.pipe(res); sreq.on('end', function()&#123; console.log('done'); &#125;);&#125;);app.listen(3001);console.log('Express started on 127.0.0.1:3001'); 启动中间层，在浏览器中输入http://127.0.0.1:3001 即可看到返回的正确内容。 以上代码不借助superagent的实现方法如下：12345678910111213141516171819202122var http = require('http');// 创建http服务var app = http.createServer(function (req, res) &#123; // 查询本机ip var sreq = http.request(&#123; host: 'sneezryworks.sinaapp.com', // 目标主机 path: '/ip.php', // 目标路径 method: req.method // 请求方式 &#125;, function(sres)&#123; sres.pipe(res); sres.on('end', function()&#123; console.log('done'); &#125;); &#125;); if (/POST|PUT/i.test(req.method)) &#123; req.pipe(sreq); &#125; else &#123; sreq.end(); &#125;&#125;);app.listen(3001);console.log('Express started on 127.0.0.1:3001'); 6. nginx反向代理利用nginx路由重写。 7. window.postMessagehttps://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage 参考 ：https://segmentfault.com/a/1190000000718840http://harttle.com/2015/10/10/cross-origin.htmlhttp://www.cnblogs.com/rainman/archive/2011/02/20/1959325.htmlJSONP ：http://www.cnblogs.com/chopper/archive/2012/03/24/2403945.html 继承的几种方法：http://www.raychase.net/149// 1var Bar = function() {};Bar.prototype = new Foo(); // 2var Bar = function () { Foo.call(this); this.name = ‘sub’;}使用instanceof发现，对象不是父类的实例。 // 3 实例继承var Sub = function(){ var instance = new Base(); instance.name = “sub”; return instance;};生成的对象实质仅仅是父类的实例，并非子类的对象；不支持多继承。 // 4 拷贝var Sub = function(){ var base = new Base(); for(var i in base) Sub.prototype[i] = base[i]; Sub.prototype[“name”] = “sub”;};效率较低；无法获取父类不可枚举的方法。 那些年，我们清除过得浮动http://www.iyunlu.com/view/css-xhtml/55.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"Hello World","date":"2017-02-01T05:07:27.000Z","path":"2017/02/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]