[{"title":"React中createClass、PureComponent、Component的不同","date":"2017-03-07T09:36:02.000Z","path":"2017/03/07/React中createClass、pureComponent、Component的不同/","text":"16年6月开始使用React，至今写法上发生了很大的变化，不过也可能是一开始接触的太low了。我使用过的创建react组件的方式大致有三种形式。 var Name = React.createClass class Name extend Component class Name extend PureComponent 友情提示：后两种需要babel转码 那么，前两种方式有哪些区别呢？首先，从createClass到class extend的改变是基于ES6的语法糖——class, 很类似于php等语言中的语法。本质上来讲，他们之间的差别不大，但是掌握他们的不同可以让我们更好的选择适合的方案。我们简单来看一下两种方法下构成的代码： createClass方式123456789101112131415161718192021222324252627282930313233import React, &#123;PureComponent&#125; from 'react';const Example = React.createClass(&#123; propTypes: &#123; title: React.PropTypes.string.isRequired &#125;, mixins: [SomeMixin], // ES6不支持 getDefaultProps() &#123; return &#123; title: 'I am title' &#125;; &#125;, getInitialState() &#123; return &#123; name: 'world' &#125; &#125;, handleClick() &#123; console.log('clicked!'); &#125;, render() &#123; return( &lt;div&gt; &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt; hello, &#123;this.state.name&#125; &lt;/div&gt; ) &#125;&#125;);export default Example; class extend方式123456789101112131415161718192021222324252627282930313233343536373839import React from 'react';class Example extends React.Component &#123; constructor(props) &#123; super(props); // super之后才能使用this this.state = &#123; name: 'world' &#125; // 重要！！ this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; console.log('clicked!'); &#125; render() &#123; const &#123;name&#125; = this.state; return( &lt;div&gt; &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt; hello, &#123;name&#125; &lt;/div&gt; ) &#125;&#125;;// 验证类型 =&gt; 对应 propTypes: &#123;&#125;Example.propsTypes = &#123; title: React.PropTypes.string.isRequired,&#125;// 设置默认属性值 =&gt; 对应 getDefaultProps() &#123;&#125;Example.defaultProps = &#123; title: 'I am title'&#125;;export default Example; 1. 语法区别敲黑板， 注意逗号 ，切忌自嗨。class extend的语法形式引入了 constructor ,方便我们调用 super() 函数来为Component传递属性。还可以传递context上下文，实现依赖注入， 这部分，下次再写 。 2. state初始化在createClass中，我们创建了一个getInitialState返回创建的state对象。在class extend方式中，我们在constructor中调用了super()之后，访问this，创建this.state，初始化声明状态。 3. this的区别（重要）createClass时，React会自动帮助我们处理 this 指向。但是，在class extend的方式中，对button进行事件绑定时，需要注意，此时this默认并没有绑定到React实例上，因此需要做相应的处理：1&lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;/button&gt; 或者如上例所示，在constructor中中调用了super()之后，改变this.handleClick执行的上下文。 那么PureComponent与直接使用Component又有什么不同呢？ PureComponent与Component的不同点在没有使用Redux的情况下，我们需要进行优化减少不必要的render时，经常需要手写shouldComponentUpdate，复杂的情况下要进行一系列深比较等。当然，也可以配合Immutable.js实现。而PureComponent的方式创建组件时，react会帮助我们进行一次 ‘浅比较’’ ，一定程度上来减少不必要的render。这里，我给浅比较加上了一个引号。 我的测试代码如下，father.js为父组件，sub.js为子组件 father.js12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123;PureComponent, Component&#125; from 'react';import Sub from './sub.js';// export default class Father extends PureComponent &#123;export default class Father extends Component &#123; constructor(props, context) &#123; super(props, context); this.state = &#123; items: [], test: undefined &#125; &#125; componentDidMount() &#123; console.log(\"father componentDidMount\"); &#125; handleClick() &#123; this.setState(&#123;items: this.state.items.concat(['new-item'])&#125;); // this.setState(prevState =&gt; (&#123; // items: prevState.items.concat(['new-item']) // &#125;)) &#125; handleClickFather() &#123; this.setState(&#123; test: '123' &#125;) &#125; render() &#123; console.log('Father --render'); return( &lt;div&gt; It is the father! &lt;button onClick=&#123;this.handleClickFather.bind(this)&#125;&gt;father Button&lt;/button&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;sub Button&lt;/button&gt; &lt;Sub items=&#123;this.state.items&#125;/&gt; &lt;/div&gt; ) &#125;&#125; sub.js1234567891011121314151617181920212223242526import React, &#123;PureComponent, Component&#125; from 'react';// export default class Sub extends PureComponent &#123;export default class Sub extends Component &#123; constructor(props, context) &#123; super(props, context); console.log('context in constructor',context); this.state = &#123; title: this.context.title &#125; &#125; componentDidMount()&#123; console.log(\"sub componentDidMount\"); &#125; render() &#123; console.log('sub --render'); return( &lt;div&gt;it is my sub, the title get from apptestpage is ---- &#123;this.state.title&#125;&lt;/div&gt; ) &#125;&#125;Sub.contextTypes = &#123; title: React.PropTypes.string&#125; 可以看出，father.js调用了sub.js,我们在father.js中设定了两个button，第一个’father button’绑定事件将会更改father组件中的state——test，这个test并未作为参数传入sub。另一个button，sub button绑定的事件将会改变items,并且sub组件接收该props。father.js与sub.js均使用 class Sub extends Component 时，点击两个按钮，发现控制台均打印：12Father --rendersub --render 也就是说，test的改变，引起了sub不必要的一次render。 之后，再使用 class Sub extends Component 创建组件，点击father button，控制台打印：1Father --render 点击sub button,控制台打印12Father --rendersub --render 此时，才是我们想要的结果。 但是 ，使用PureComponent，需要注意的是，我此时使用的方法是数组的concat，concat有一个特点是会新创建一个数组对象，假如使用push方法，就会出现sub.js不进行render的情况。也就是说，PureComponent比较的是简单类型的值，或者对象的地址，这些内容都有一个特点，应该是存在栈当中的（恩，才疏学浅，我是这么骗自己的。如果错了，不要当真）。因此，在大多数情况下，我们还是需要手写shouldComponentUpdate滴。恩，当然，还可以移步redux。 好了，不喜欢写文档的我，写到这里我已经用尽洪荒之力了。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"Reactjs","slug":"Reactjs","permalink":"http://yoursite.com/tags/Reactjs/"}]},{"title":"JS数组去重","date":"2017-02-25T08:44:54.000Z","path":"2017/02/25/JS数组去重/","text":"注意 ：需要注意包含NaN类型数据的去重 使用Array.prototype.indexOf(), indexOf使用的是严格等 ‘===’ 思路1 =&gt; arr.filter()12345function unique(arr) &#123; return arr.filter(function(item, index) &#123; return arr.indexOf(item) === index; &#125;)&#125; 思路2 =&gt; arr.forEach()123456789function unique(arr) &#123; var ret = []; arr.forEach(function(item) &#123; if (ret.indexOf(item) === -1) &#123; ret.push(item); &#125; &#125;); return ret;&#125; 思路3 =&gt; es2015新增方法includes 解决NaN123456789function unique(arr) &#123; var ret = []; arr.forEach(function(item) &#123; if (!ret.includes(item)) &#123; ret.push(item); &#125; &#125;); return ret;&#125; 思路4 =&gt; 借助set，map等ES6新增类型https://www.toobug.net/article/array_unique_in_javascript.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"小白眼中的跨域","date":"2017-02-15T13:02:20.000Z","path":"2017/02/15/小白眼中的跨域/","text":"跨域，这个纠结好久的问题，最近终于有些思路了。仿佛预见了自己将要不是哪个懒得只知道用cors中间件的小白啦！ 什么是跨域我们来看一下什么是跨域以及同源策略： 通过XHR实现Ajax通信的的主要限制，来源于跨域安全策略。所谓同源是指，域名，协议，端口相同。默认情况下，XHR对象只能访问与包含它的页面位于同一个域的资源。这种安全策略可以预防某些恶意行为。简单来说，形如a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。 跨域的几种情况下表所示： URL1 URL2 说明 通信否 http://www.a.com/a.js http://www.a.com/b.js 同一域名下 可 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名不同文件夹 可 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名不同端口 否 http://www.a.com/a.js https://www.a.com/b.js 同一域名不同协议 否 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 否 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 否 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 否（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 否 其中，如果是协议和端口造成的跨域问题前端是无能为力的；而且，在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。 如何解决跨域问题跨域问题的解决办法有很多种,大致可以分为两类： 一类是Hack，比如通过title、navigation、script等对象传递信息， JSONP 就是一种Hack方式; 另一类是HTML5支持，其中一种是 Access-Control-Allow-Origin 响应头，一个是 window.postMessage ; 1. JSONP 实现原理：虽然我们不能直接请求异源上的资源，但是在js中如img，script标签却是可以得到其他服务器上的资源的，那么我们就可以通过这样的方式将一段js代码间接地从外部引入。通过script标签向目标源发起一个GET请求，服务器根据请求的参数返回包含js的代码。 JSONP是JSON with Padding的简写，是一个非官方协议，她允许在服务端集成Script Tags返回客户端，通过javascript callback的形式实现跨域访问（注：简单实现形式是这样）。 缺点：JSONP只能实现GET请求。随着现在RESTful的兴起，JSONP显得力不从心了。因为，RESTful不仅有GET，还存在POST、PUT、PATCH、DELETE等等。 下面为index.html的代码：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jsonp test&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; var url = 'ticker.js'; function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute('src', src); document.body.appendChild(script); &#125; function callBack(data) &#123; console.log(data); &#125; window.onload = function() &#123; addScriptTag(url); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其中，ticker.js中的内容如下：123456callBack( &#123; name:'iwtofly', job: 'FE' &#125;) 结果显示如下： 此外还有很多好玩的地方可以小探索一下，例如google、Flickr等等都提供了JSONP的回调接口，笔者不才最近正在小玩了下Flickr，等稍有成果之后再做呈现。 2. iframe + domain原理 —— 形如http://a.com/video 与 http://b.a.com/video、http://c.a.com/video 这种 主域相同，子域不同的情况，可以通过设置document.domain让它们同域。限制 —— 同域document提供的是页面间的相互操作，需要载入iframe页面(即，只能通过页面嵌套的方式) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.domain用来得到当前网页的域名，给document.domain属性赋值是有限制的 —— 只能赋成当前的域名或者基础域名。http://b.a.com/ 为当前域名，http://a.com/ 为基础域名。因此，利用document.domain实现跨域前提条件为，这两个域名必须属于同一个基础域名而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。12345678910// 当前为http://iwtofly.cn/videovar ifr = document.createElement('iframe');ifr.src = 'http://www.iwtofly.cn/video'; ifr.onload = function()&#123; var ifrdoc = ifr.contentDocument || ifr.contentWindow.document; ifrdoc.getElementsById(\"foo\").innerHTML);&#125;;ifr.style.display = 'none';document.body.appendChild(ifr); 假设上述代码所在的URL为http://iwtofly.cn/video ，它对http://www.iwtofly.cn/video 的DOM访问要求后者将document.domain往上设置一级:1document.domain = iwtofly.cn; document.domain 只能从子域设置到主域，往下设置以及往其他域名设置都是不允许的 3. cors CORS（Cross Origin Resource Sharing, 跨源资源共享）是W3C的一个工作草案，定义了在必须访问跨源资源时浏览器与服务器应该如何进行沟通。其背后的思想，就是定义HTTP头部让浏览器与服务器进行沟通，从而决定请求或相应的成功与否，以便服务器根据这个头部信息来决定是否给予相应。 Origin头部示例：1Origin: http://iwtofly.cn 如果服务器认为这个来源的请求是可以接受的，就在Access-Control-Allow-Origin头部中回发相同的源信息，’*’代表允许一切来源的请求，一般设置为公共资源。示例：1Access-Control-Allow-Origin: http://iwtofly.cn 笔者用过这方面的工具有nodejs cors中间件。cors中间件在使用前需要安装cors模块：1$ npm install cors --save 然后，在 index.js 内添加中间件 app.use(cors());1234567891011121314151617181920var express = require('express');var app = express();var cors =require('cors');app.use(cors()); // 作用于全局的请求app.get('/table',function (req, res) &#123; res.send(data);&#125;)// 只用于'/table'的GET的写法// app.get('/table', cors(), function (req, res) &#123;// res.send(data);// &#125;);var server = app.listen(8988, function () &#123; var host = server.address().address; var port = server.address().port; console.log('back server: http://%s:%s', host, port);&#125;) 只有使用 cors()中间件才会释放出我们 Api 的访问权限。最好是控制哪些客户端可以进行连接，哪些方法可以使用。最主要的是，必须要在请求的时候加入到头部。在我们这个例子中仅需要设置三个属性： orgin（访问域）、method（访问方法）、alloweHeaders（请求头）。12345678910111213141516171819var express = require('express'); var cors = require('cors'); var app = express();app.use(cors(&#123; origin: ['http://localhost:3001'], methods: ['GET', 'POST'], alloweHeaders: ['Conten-Type', 'Authorization']&#125;));app.get('/', function(req, res) &#123; res.json(&#123;status: 'My Api is alive!'&#125;);&#125;);app.listen(3000, function() &#123; console.log('My Api is running...');&#125;);module.exports = app; 4. 中间层代理跨域问题的核心是不同源访问，因此，如果我们转换为同源请求，就不存在这个问题啦。通过搭建中间层，可以是java，也可以是node.js，通过将服务端的请求进行转发，换句话说，就是dispatcher了一层，那么前端请求的地址，就被转发了，所以很好的解决跨域问题。缺点：如果对性能有考量的产品，就需要慎重选择这个方案，因为多了一层中间转发，不管是网络开销，还是性能负载都是有一定的影响。 做了一个小测试，假设以下为server2.js,我们真正要请求的后端，运行在3002端口：1234567891011121314/** * 中间层跨域中的：server后端 */var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.json(&#123; name: 'iwtofly', job: 'FE' &#125;)&#125;);app.listen(3002);console.log('Express started on 127.0.0.1:3002'); 前端资源位于不同的域 ，但又想要对http://127.0.0.1:3002 的内容进行请求，我们可以搭建一个中间层，来转发请求。对于前端来说是对中间层进行了请求。中间层为server.js代码如下，利用了express + superagent：12345678910111213141516171819/** * 中间层跨域中的：中间层 */var express = require('express');var app = express();app.get('/', function (req, res) &#123; // 使用了superagent来发起请求 var superagent = require('superagent'); // 查询本机ip，这里需要根据实际情况选择get还是post var sreq = superagent.get('http://127.0.0.1:3002/'); sreq.pipe(res); sreq.on('end', function()&#123; console.log('done'); &#125;);&#125;);app.listen(3001);console.log('Express started on 127.0.0.1:3001'); 启动中间层，在浏览器中输入http://127.0.0.1:3001 即可看到返回的正确内容。 以上代码不借助superagent的实现方法如下：12345678910111213141516171819202122var http = require('http');// 创建http服务var app = http.createServer(function (req, res) &#123; // 查询本机ip var sreq = http.request(&#123; host: 'sneezryworks.sinaapp.com', // 目标主机 path: '/ip.php', // 目标路径 method: req.method // 请求方式 &#125;, function(sres)&#123; sres.pipe(res); sres.on('end', function()&#123; console.log('done'); &#125;); &#125;); if (/POST|PUT/i.test(req.method)) &#123; req.pipe(sreq); &#125; else &#123; sreq.end(); &#125;&#125;);app.listen(3001);console.log('Express started on 127.0.0.1:3001'); 5. nginx反向代理利用nginx路由重写，example like this:1234location ^~/proxy/html/&#123; rewrite ^/proxy/html/(.*)$ /$1 break; proxy_pass http://www.b.com/;&#125; ^~/proxy/html/匹配任何以 /proxy/html/开头的地址。 6. window.postMessagepostMessage接收两个参数，一个是想要发送的信息，第二个是要发送至的origin。在接收端，需要监听message事件，并且制定事件源。测试如下： 打开https://www.baidu.com ，开发者模式下，在控制台输入：123window.addEventListener('message','http://iwtofly.cn',function(event) &#123; console.log(event.data);&#125;); 打开http://iwtofly.cn ，开发者模式下，在控制台输入：12var win = window.open('https://www.baidu.com');win.postMessage('Hello, I am iwtofly', 'https://www.baidu.com'); 可以看到，在百度首页的控制台打印出接收到的信息。关于postMessage详细信息，见 https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage 。 参考：https://segmentfault.com/a/1190000000718840http://harttle.com/2015/10/10/cross-origin.htmlhttp://www.cnblogs.com/rainman/archive/2011/02/20/1959325.htmlJSONP：http://www.cnblogs.com/chopper/archive/2012/03/24/2403945.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"Hello World","date":"2017-02-01T05:07:27.000Z","path":"2017/02/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]