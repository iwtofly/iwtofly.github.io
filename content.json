[{"title":"Rust笔记二（数据类型、函数）","date":"2018-02-04T13:48:50.000Z","path":"2018/02/04/Rust学习笔记二（数据类型、函数）/","text":"1. 复合数据类型元组和数组：tuples and arrays. 支持解构赋值 1.1 元组1234567fn main() &#123; let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(&quot;The value of y is: &#123;&#125;&quot;, y);&#125; 解构赋值取出y，6.4。123456789fn main() &#123; let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2;&#125; Array数组和元组不同，数组的每个元素必须具有相同的数据类型。 数组的长度是一个固定值。 Arrays in Rust are different than arrays in some other languages because arrays in Rust have a fixed length: once declared, they cannot grow or shrink in size. 12345678fn main() &#123; let a = [1, 2, 3, 4, 5]; let index = 10; let element = a[index]; println!(&quot;The value of element is: &#123;&#125;&quot;, element);&#125; 如果访问的下标超过数组长度，rust只会在编译时进行提醒不会报错。运行时会panic。 2. 函数同js，函数定义的位置（前后）对调用没有影响。 123456789fn main() &#123; println!(&quot;Hello, world!&quot;); another_function();&#125;fn another_function() &#123; println!(&quot;Another function.&quot;);&#125; 2.1 函数参数注意： 参数类型必须指定 多个参数用逗号分隔 12345678fn main() &#123; another_function(5, 6);&#125;fn another_function(x: i32, y: i32) &#123; println!(&quot;The value of x is: &#123;&#125;&quot;, x); println!(&quot;The value of y is: &#123;&#125;&quot;, y);&#125; 2.2 函数体","tags":[{"name":"rust","slug":"rust","permalink":"http://yoursite.com/tags/rust/"}]},{"title":"Decorator","date":"2018-01-24T13:48:50.000Z","path":"2018/01/24/Decorator/","text":"装饰器，ES提案。用来修改类的行为。 装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。 1. 类修饰装饰器可以对类进行修饰 1.1 有参数的装饰器一个参数不够用，可以在修饰器外面再封装一层函数。12345678910111213function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable; &#125;&#125;@testable(true)class MyTestableClass &#123;&#125;MyTestableClass.isTestable // true@testable(false)class MyClass &#123;&#125;MyClass.isTestable // false 为类添加了静态属性。 1.2 在prototype上添加相应方法上面的例子是为类添加了静态属性，如果想添加实例属性，可以通过目标类的prototype对象操作： 12345678910111213141516171819// mixins.jsexport function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list) &#125;&#125;// main.jsimport &#123; mixins &#125; from &apos;./mixins&apos;const Foo = &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // &apos;foo&apos; 等同于 12345678910const Foo = &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;class MyClass &#123;&#125;Object.assign(MyClass.prototype, Foo);let obj = new MyClass();obj.foo() // &apos;foo&apos; 2. 方法修饰装饰器不仅可以修饰类，还可以修饰类的属性： 1234class Person &#123; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125; name方法被readonly修饰。 修饰器函数readonly一共可以接受三个参数: target, name, descriptor。 123456789101112131415function readonly(target, name, descriptor)&#123; // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor;&#125;readonly(Person.prototype, &apos;name&apos;, descriptor);// 类似于Object.defineProperty(Person.prototype, &apos;name&apos;, descriptor); 注意： 多个装饰器的执行顺序： 同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。 123456789class Example &#123; @dec(1) @dec(2) method()&#123;&#125;&#125;// evaluated 1// evaluated 2// executed 2// executed 1 外层dec(1)先进入，因此输出evaluated 1之后输出evaluated 2；但是内层装饰器dec(2)会先执行，输出：executed 2之后输出executed 1。 3. 函数修饰一般装饰器不能用于函数，因为： 函数存在提升。 123456789var counter = 0;var add = function () &#123; counter++;&#125;;@addfunction foo() &#123;&#125; 上面这段代码并不能使counter为1，因为实际执行的代码如下： 1234567891011@addfunction foo() &#123;&#125;var counter;var add;counter = 0;add = function() &#123; counter++;&#125; 如果一定要修饰函数，可以采用高阶函数的形式执行: 12345678910111213141516171819function doSomething(name) &#123; console.log(&apos;Hello, &apos; + name);&#125;function loggingDecorator(wrapped) &#123; return function() &#123; console.log(&apos;Starting&apos;); const result = wrapped.apply(this, arguments); console.log(&apos;Finished&apos;); return result; &#125;&#125;const wrapped = loggingDecorator(doSomething);wrapped(&apos;wf&apos;);// Starting// Hello, wf// Finished 4. core-decorators.jscore-decorators.js是个第三方模块，提供了几个常见的装饰器，我们的项目中就在用，最常用的就是autobind： 4.1 @autobindautobind修饰器使得方法中的this对象，绑定原始对象。 1234567891011121314import &#123; autobind &#125; from &apos;core-decorators&apos;;class Person &#123; @autobind getPerson() &#123; return this; &#125;&#125;let person = new Person();let getPerson = person.getPerson;getPerson() === person;// true React组件中，组件内部的方法经常在调用处需要bind， 1onClick=&#123;this.handleClick.bind(this)&#125; 或者在constructor中进行初始化 1this.handleClick = this.handleClick.bind(this); 在类（组件）上使用@autobind就可以省去组件中各个方法的bind。 4.2 @readonlyreadonly修饰器使得属性或方法不可写。 12345678910import &#123; readonly &#125; from &apos;core-decorators&apos;;class Meal &#123; @readonly entree = &apos;steak&apos;;&#125;var dinner = new Meal();dinner.entree = &apos;salmon&apos;;// Cannot assign to read only property &apos;entree&apos; of [object Object] 4.3 @overrideoverride修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。 4.4 @deprecate (别名@deprecated)deprecate或deprecated修饰器在控制台显示一条警告，表示该方法将废除。 4.5 @suppressWarningssuppressWarnings修饰器抑制deprecated修饰器导致的console.warn()调用。但是，异步代码发出的调用除外。 5. Mixin装饰器可以实现Mixin模式，就是对象继承的一种替代方案。中文译为混入，以为在一个对象中混入另一个对象的方法。 简单的混入例如： 123456789const Foo = &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;class MyClass &#123;&#125;Object.assign(MyClass.prototype, Foo);let obj = new MyClass();obj.foo() // &apos;foo&apos; 通过Object.assign方法，可以将foo方法混入MyClass类，使其实例对象都具有foo方法。 将mixin写成装饰器如下（mixin.js）： 12345export function mixins(...list) &#123; return function(target) &#123; Object.assign(target.prototype, ...list); &#125;&#125; 然后，就可以使用上面的装饰器，为类混入各种方法。 1234567891011import &#123; mixins &#125; from &apos;./mixins&apos;;const Foo = &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // &quot;foo&quot;","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Rust学习 笔记1","date":"2018-01-22T13:48:50.000Z","path":"2018/01/22/Rust学习/","text":"Rust 是一个系统编程语言，它注重于三个方面：安全，速度和并发性。为了实现这些目标，它没有采用垃圾回收机制（GC）。这让它在其它语言并不擅长的场景中大展身手：嵌入到其它语言中、在特定的时间和空间要求下编程、编写例如设备驱动和操作系统这样的底层代码。它通过一系列不产生运行时开销的编译时安全检查来提升目前语言所关注的领域，同时消除一切数据竞争。Rust 还致力于实现“零开销抽象”，虽然有些抽象看起来更像一个高级语言的特性。即便如此，我们仍然可以使用 Rust 来做一些底层的精准控制。 Rust准备macOS和Linux下 1curl https://sh.rustup.rs -sSf | sh 卸载： 1rustup self uninstall 版本信息获取： 1rustc --version 如果rustc –version不起作用，可以先重启或者重新开一个终端窗口尝试。如果仍然不起作用，则需要： 1vim ~/.bash_profile 查看有没有如下信息，如果没有，需要添加： 1export PATH=&quot;$HOME/.cargo/bin:PATH&quot; hello Worldrust文件以 .rs 结尾，新建一个main.rs，写入如下代码： 123fn main() &#123; println!(&quot;Hello, world!&quot;);&#125; 保存，编译、运行： 12$ rustc main.rs // 编译，生成可执行文件 main$ ./main 与 C 相同，main 函数是所有Rust程序的开始。在这里参数和返回值缺省。 println!() 这一行。这是一个 Rust 宏，是 Rust 元编程的关键所在。如果是函数调用是println()（没有！），“！”代表了宏调用。 与js不同，；不能缺省。 Hello, Cargo!Cargo 是 Rust 的构建系统和包管理工具，同时 Rustacean 们使用 Cargo 来管理它们的 Rust 项目。Cargo 负责三个工作：构建你的代码，下载你代码依赖的库并编译这些库。我们把你代码需要的库叫做“依赖（dependencies）”因为你的代码依赖他们。与之相对应js中的yarn稍微有点类似。 使用官方安装包安装Rust会自带Cargo，我们可以用如下命令检查是否安装了Cargo： 1$ cargo --version 如果得到版本号，则Cargo安装成功。 Cargo 化将Hello World 程序迁移至 Cargo，需要做以下几步： 将源文件放到正确的目录 删除旧的可执行文件（main.exe或main） 创建Cargo配置文件 1. 创建源文件目录并移除旧的可执行文件123$ mkdir src$ mv main.rs src/main.rs # or &apos;move main.rs src/main.rs&apos; on Windows$ rm main # or &apos;del main.exe&apos; on Windows 仍然使用main.rs作为源文件名是因为它创建了一个可执行文件。 如果想要创建一个库文件，使用lib.rs作为文件名。Cargo 使用这个约定来正确编译你的项目，不过如果你愿意的话也可以覆盖它。 2. 创建配置文件Cargo.tomlCargo使用Cargo.toml作为配置文件，其中Cargo.toml 的 C 是大写的。TOML类似于INI以及YAML。 在配置文件中，输入： 12345[package]name = &quot;hello_world&quot;version = &quot;0.0.1&quot;authors = [ &quot;Your name &lt;you@example.com&gt;&quot; ] [package]表明下面的语句用来配置一个包。随着我们在这个文件增加更多的信息，我们会增加其他部分例如dependencies，不过现在，我们只有包配置。其他信息比较明显，类似于package.json，定义了包的名字，版本号，作者。 3. 构建并运行 Cargo 项目可以分两步： 12$ cargo build$ ./target/debug/hello_world 也可合并为一步： 1$ cargo run 4. 发布构建需要发布给用户时可以执行以下： 1cargo build --release 优化Rust代码，使其可以运行的更快，但是编译比较耗时。类似于前端代码构建分为webpack.config.dev.js和webpack.config.prod.js。在开发环境下，不需要实时的压缩与优化，提高开发效率。 其中Cargo.lock类似于yarn.lock，跟踪依赖版本。 迅速创建Cargo项目Cargo也可以看做是一个简单的脚手架，类似于create-react-app，使用 cargo new 可以简单初始化项目。 1$ cargo new hello_world --bin –bin参数是可选的，在此标明项目目标是直接创建一个可执行程序，而不是一个库。执行之后，Cargo 为我们创建了两个文件和一个目录：一个Cargo.toml和一个包含了main.rs文件的src目录。 其中Cargo.toml为： 1234567[package]name = &quot;hello_world&quot;version = &quot;0.1.0&quot;authors = [&quot;Your Name &lt;you@example.com&gt;&quot;][dependencies] 并且cargo根据git全局配置已经配好了邮箱等信息。 hello world进阶——猜猜看(guessing-game)体会：Rust 真的是有一个强大的静态类型系统！新建工程： 12$ cargo new guessing_game --bin$ cd guessing_game 自动生成了Cargo.toml以及src/main.rs文件（内容为hello world初始化）。 后续修改及执行： 12$ cargo build$ ./target/debug/guessing_game 或者 1$ cargo run 处理一次猜测编辑src/main.rs： 1234567891011121314use std::io;fn main() &#123; println!(&quot;Guess the number!&quot;); println!(&quot;Please input your guess.&quot;); let mut guess = String::new(); io::stdin().read_line(&amp;mut guess) .expect(&quot;Failed to read line&quot;); println!(&quot;You guessed: &#123;&#125;&quot;, guess);&#125; 其中： 1use std::io; 我们需要获取用户输入，并接着打印结果作为输出。为此，我们需要标准库的io库。Rust 为所有程序只导入了很少一些东西，‘prelude’。如果它不在预先导入中，你将不得不直接use它。这还有第二个”prelude”，io prelude，它也起到了类似的作用：你引入它，它引入一系列拥有的 IO 相关的库。 main是程序入口，fn声明了一个没有参数的新函数，返回值为空。 123println!(&quot;Guess the number!&quot;);println!(&quot;Please input your guess.&quot;); println!()是一个在屏幕上打印字符串的宏。 1let mut guess = String::new(); 前面我们知道let 用于变量定义，mut使绑定可变。let并不从左手边获取一个名字，事实上它接受一个模式（pattern）。我们会在后面更多的使用模式。现在它使用起来非常简单： 12let foo = 5; // immutable.let mut bar = 5; // mutable let mut guess引入了一个名为guess的可变绑定，=右侧 String::new()。 String是一个字符串类型，由标准库提供。String是一个可增长的，UTF-8编码的文本。 ::new() 语法用了 :: 因为它是一个特定类型的”关联函数“。这就是说，它与String自身关联，而不是与一个特定的String实例关联。一些语言管这叫一个“静态方法”（emmmm，说的好像是js呢）。 123// 代码段1 io::stdin().read_line(&amp;mut guess) .expect(&quot;Failed to read line&quot;); 代码开头引入了use std::io，在这里io::stdin() 调用了其中的函数stdin，在开头引入之后，拥有了本地的缩写的命名空间io，否则需要写成’std::io::stdin()‘。 这个特殊的函数返回一个指向你终端标准输入的句柄。更具体的，可参考std::io::Stdin。 用句柄去调用方法readline获取用户输入： 1.read_line(&amp;mut guess) “方法”就像关联函数，不过只在一个类型的特定实例上可用，而不是这个类型本身。我们也向read_line()传递了一个参数：&amp;mut guess。 guess是可变的，然而，read_line并不接收String作为一个参数：它接收一个&amp;mut String。Rust有一个叫做“引用”的功能，它允许你对一片数据有多个引用，用它可以减少拷贝。引用是一个复杂的功能，因为Rust的一个主要卖点就是它如何安全和便捷地使用引用。然而，目前我们还不需要知道很多细节来完成我们的程序。现在，所有我们需要了解的是像let绑定，引用默认是不可变的。因此，我们需要写成&amp;mut guess，而不是&amp;guess。 为什么read_line()会需要一个字符串的可变引用呢？它的工作是从标准输入获取用户输入，并把它放入一个字符串。所以它用字符串作为参数，为了可以增加输入，它必须是可变的。 1.expect(&quot;Failed to read line&quot;); 上面这段代码占用了新的一行，这个有点类似于js链式操作，我们未来拆分长的行，可以代码分开写在不同的行。 expect的作用： read_line()将用户输入放入我们传递给它的&amp;mut String中的同时，会返回一个值，在这个例子中，是一个io::Result。Rust的标准库中有很多叫做Result的类型：一个泛型Result，然后是子库的特殊版本，例如io::Result。 这个Result类型的作用是编码错误处理信息。Result类型的值，像任何（其它）类型，有定义在其上的方法。在这个例子中，io::Result有一个expect()方法获取调用它的值，而且如果它不是一个成功的值，panic!并带有你传递给它的信息。这样的panic!会使我们的程序崩溃 ，显示（我们传递的）信息。 去掉expect，cargo build编译会通过，但是会显示警告，包含信息 1warning: unused result which must be used,··· Rust警告我们我们并未使用Result的值。这个警告来自io::Result的一个特殊注解。Rust 尝试告诉你你并未处理一个可能的错误。阻止错误的正确方法是老实编写错误处理。 1println!(&quot;You guessed: &#123;&#125;&quot;, guess); 将结果输出，{} 为占位符，类似于%d、%s。 123456789cargo run Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game) Finished debug [unoptimized + debuginfo] target(s) in 0.44 secs Running `target/debug/guessing_game`Guess the number!Please input your guess.6You guessed: 6 生成秘密数字——引入crateRust标准库中还未包含随机数功能。然而，Rust 团队确实提供了一个rand crate。一个“包装箱”（crate）是一个 Rust 代码的包。我们已经构建了一个”二进制包装箱“，它是一个可执行文件。rand是一个”库包装箱“，它包含被认为应该被其它程序使用的代码。 使用外部包装箱是 Cargo 的亮点(emmm，可以和npm中的中间件和库相对应)。在我们使用rand编写代码之前，我们需要修改我们的Cargo.toml。打开它，并在末尾增加这几行： 123[dependencies]rand = &quot;0.3.0&quot; Cargo.toml 的 [dependencies] 部分就像 [package] 部分：所有之后的东西都是它的一部分，直到下一个部分开始。Cargo 使用依赖部分来知晓你用的外部包装箱的依赖，和你要求的版本。在这个例子中，我们用了 0.3.0 版本。Cargo 理解语义化版本，它是一个编写版本号的标准。像上面只有数字的版本事实上是 ^0.3.0 的简写，代表“任何兼容 0.3.0 的版本”。如果你只想使用 0.3.0 版本，你可以使用rand = “=0.3.0”（注意那两个双引号）。我们也可以指定一个版本范围。Cargo文档包含更多细节。 运行： 1$ cargo build 会有新的日志输出，显示Downloading rand 、libc， Compile等。 现在我们有了一个外部依赖，Cargo 从记录中获取了所有东西的最新版本，它们是来自Crates.io的一份拷贝。Crates.io 是 Rust 生态系统中人们发表开源 Rust 项目供他人使用的地方。 再次build就会显示类似于 1Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs 因为Cargo 知道我们的项目被构建了，并且所有它的依赖也被构建了，所以没有理由再做一遍所有这些。没有事情做，它简单地退出了。如果我们d对main.rs进行修改后再次build，会得到新的Compile信息。 我们告诉Cargo我们需要任何0.3.x版本的rand，并且因此它获取在本文被编写时的最新版，v0.3.14。 Cargo.lock的存在：当你第一次构建你的项目的时候，Cargo 查明所有符合你的要求的版本，并接着把它们写到了Cargo.lock文件里。当你在未来构建你的项目的时候，Cargo 会注意到Cargo.lock的存在，并接着使用指定的版本而不是再次去做查明版本的所有工作。这让你有了一个可重复的自动构建。换句话说，我们会保持在0.3.8直到我们显式的升级，这对任何使用我们共享的代码的人同样有效，感谢锁文件。 如果确实想要使用某个版本例如 v0.3.15，cargo有 update 命令，代表忽略锁，获取指定的最新版本（0.3.x下的最新版本）。如果需要0.4.x，则需要更新Cargo.toml，Cargo build之后，Cargo会重新计算。 Cargo让重用库变得真正的简单，并且Rustacean们可以编写更小的由很多子包组装成的项目。 使用rand: 12345678910111213141516171819202122extern crate rand; // 新 code 1use std::io;use rand::Rng; // 新 code 2fn main() &#123; println!(&quot;Guess the number!&quot;); let secret_number = rand::thread_rng().gen_range(1, 101); // 新 code 3 println!(&quot;The secret number is: &#123;&#125;&quot;, secret_number); // 新 code 3 println!(&quot;Please input your guess.&quot;); // String类型，默认i32（32位有符号整型） let mut guess = String::new(); io::stdin().read_line(&amp;mut guess) .expect(&quot;failed to read line&quot;); println!(&quot;You guessed: &#123;&#125;&quot;, guess);&#125; code 1: extern crate rand，因为在[dependencies]声明了rand，我们可以用extern crate来让Rust知道我们正在使用它。这也等同于一个use rand;，所以我们可以通过rand::前缀使用rand包装箱中的一切。 code 2: use rand::Rng, 我们增加了一个use，要求要求Rng在作用域中才能工作。 123let secret_number = rand::thread_rng().gen_range(1, 101);println!(&quot;The secret number is: &#123;&#125;&quot;, secret_number); code 3: rand::thread_rng()函数来获取一个随机数生成器的拷贝，它位于我们特定的执行线程的本地。因为use rand::Rng了，有一个gen_range()方法可用。这个函数获取两个参数，并产生一个位于其间的数字。它包含下限，不过不包含上限，所以需要1和101来生成一个1和100之间的数。 可以cargo run一下，看看此时是否输出了secret_number。 比较猜测这里又引入了一个标准库，Code 1加了一个叫做std::cmp::Ordering类型到作用域中。 1234567891011121314151617181920212223242526272829extern crate rand; use std::io;use std::cmp::Ordering; // Code 1use rand::Rng;fn main() &#123; println!(&quot;Guess the number!&quot;); let secret_number = rand::thread_rng().gen_range(1, 101); println!(&quot;The secret number is: &#123;&#125;&quot;, secret_number); println!(&quot;Please input your guess.&quot;); let mut guess = String::new(); io::stdin().read_line(&amp;mut guess) .expect(&quot;failed to read line&quot;); println!(&quot;You guessed: &#123;&#125;&quot;, guess); // Code 2 match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;Too big!&quot;), Ordering::Equal =&gt; println!(&quot;You win!&quot;), &#125;&#125; Code 2 对cmp进行了使用，cmp()可以在任何能被比较的值上调用，它返回我们之前use的Ordering类型。 match语句用来决定具体是哪种Ordering。Ordering是一个枚举（enum），形如： 1234enum Foo &#123; Bar, Baz,&#125; 任何Foo可以是Foo::Bar或者Foo::Baz。我们用::来表明一个特定enum变量的命名空间。 Ordering枚举有3个可能的变量：Less，Equal和Greater。match语句获取类型的值，并让你为每个可能的值创建一个“分支”。因为有 3 种类型的Ordering，Code 2中，我们有 3 个分支。 但是上面这段代码build会报错：‘mismatched types‘。类型不匹配，位置在’match guess.cmp(&amp;secret_number)‘这里。 Rust 有一个强大的静态类型系统。然而，它也有类型推断。let guess = String::new()，Rust能够推断出guess应该是一个String。而secret_number，有很多类型，可以是从1到100的值：i32，一个 32 位数，或者u32，一个无符号的32位值，或者i64，一个 64 位值。 所以我们需要把输入的string类型进行转换： 12345678910111213141516171819202122232425262728293031extern crate rand;use std::io;use std::cmp::Ordering;use rand::Rng;fn main() &#123; println!(&quot;Guess the number!&quot;); let secret_number = rand::thread_rng().gen_range(1, 101); println!(&quot;The secret number is: &#123;&#125;&quot;, secret_number); println!(&quot;Please input your guess.&quot;); let mut guess = String::new(); io::stdin().read_line(&amp;mut guess) .expect(&quot;failed to read line&quot;); let guess: u32 = guess.trim().parse() // Code new .expect(&quot;Please type a number!&quot;); println!(&quot;You guessed: &#123;&#125;&quot;, guess); match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;Too big!&quot;), Ordering::Equal =&gt; println!(&quot;You win!&quot;), &#125;&#125; Rust允许遮盖(shadow)变量，经常被用到。guess开始是一个String，我们把它转换为了u32。遮盖（Shadowing）让我们重用guess名字，而不是强迫我们定义两个独特的像guess_str和guess，或者别的什么。 1guess.trim().parse() 根据字面猜测可知，trim是除去字符串首尾输入的空格回车等，parse方法将字符串解析为一些类型的数字，其中’: u32’就是要转换的数字类型（无符号整型）。 到这里这个程序可以执行，但是每次执行一次之后就退出代码。所以，可以加个循环。 循环Rust loop关键字可以无限循环： 123456789101112131415161718192021222324252627282930313233extern crate rand;use std::io;use std::cmp::Ordering;use rand::Rng;fn main() &#123; println!(&quot;Guess the number!&quot;); let secret_number = rand::thread_rng().gen_range(1, 101); println!(&quot;The secret number is: &#123;&#125;&quot;, secret_number); loop &#123; println!(&quot;Please input your guess.&quot;); let mut guess = String::new(); io::stdin().read_line(&amp;mut guess) .expect(&quot;failed to read line&quot;); let guess: u32 = guess.trim().parse() .expect(&quot;Please type a number!&quot;); println!(&quot;You guessed: &#123;&#125;&quot;, guess); match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;Too big!&quot;), Ordering::Equal =&gt; println!(&quot;You win!&quot;), &#125; &#125;&#125; 只有在给出一个非数字回答，会panic!并退出程序。但是我们需要在赢的时候退出，因此，可以改为： 123456789101112131415161718192021222324252627282930313233343536extern crate rand;use std::io;use std::cmp::Ordering;use rand::Rng;fn main() &#123; println!(&quot;Guess the number!&quot;); let secret_number = rand::thread_rng().gen_range(1, 101); println!(&quot;The secret number is: &#123;&#125;&quot;, secret_number); loop &#123; println!(&quot;Please input your guess.&quot;); let mut guess = String::new(); io::stdin().read_line(&amp;mut guess) .expect(&quot;failed to read line&quot;); let guess: u32 = guess.trim().parse() .expect(&quot;Please type a number!&quot;); println!(&quot;You guessed: &#123;&#125;&quot;, guess); match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;Too big!&quot;), Ordering::Equal =&gt; &#123; println!(&quot;You win!&quot;); break; &#125; &#125; &#125;&#125; 实现了win退出，但是输入非数字的错误情况未进行处理。对此进行处理，忽略输入的非数字的最终代码： 123456789101112131415161718192021222324252627282930313233343536373839404142extern crate rand;use std::io;use std::cmp::Ordering;use rand::Rng;fn main() &#123; println!(&quot;Guess the number!&quot;); let secret_number = rand::thread_rng().gen_range(1, 101); loop &#123; println!(&quot;Please input your guess.&quot;); // String类型，默认i32（32位有符号整型） let mut guess = String::new(); io::stdin().read_line(&amp;mut guess) .expect(&quot;failed to read line&quot;); // Rust中可以覆盖原有变量，u32为32位无符号整型 let guess: u32 = match guess.trim().parse() &#123; Ok(num) =&gt; num, // new Code Err(_) =&gt; continue, &#125;; // let guess: u32 = guess.trim().parse() // .expect(&quot;Please type a number!&quot;); println!(&quot;You guessed: &#123;&#125;&quot;, guess); match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;Too big!&quot;), Ordering::Equal =&gt; &#123; println!(&quot;You win!&quot;); break; &#125; &#125; &#125; println!(&quot;The secret number is: &#123;&#125;&quot;, secret_number);&#125; 从之前的”错误就崩溃“ 优化为 ”确实处理错误“，从expect()切换到一个match语句。parse()返回的Result就是一个像Ordering一样的枚举，不过在这个例子中，每个变量有一些数据与之相关：Ok是一个成功，而Err是一个失败，成功的解析为整型，或一个错误类型。 这回可以愉快的玩耍了，还可以手动测试下二分法和一脸懵逼随机猜测的速度区别。 总结 ‘;’ 不能省略； Rust编译会进行参数类型检测，所以要确定自己的类型正确。 Rust类似于js有很多crate库可以引用。 match常用方式 关联函数（js ES7也有::） 参考 Cargo和它的生态系统 parse","tags":[{"name":"rust","slug":"rust","permalink":"http://yoursite.com/tags/rust/"}]},{"title":"class继承","date":"2018-01-19T13:48:50.000Z","path":"2018/01/19/class继承/","text":"1234567class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125; super在这里相当于： A.prototype.constructor.call(this) ES6 规定，通过super调用父类的方法时，方法内部的this指向子类。 例1： 123456789101112131415161718192021class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m() &#123; super.print(); &#125;&#125;let b = new B();b.m() // 2 super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。 例2： 12345678910111213141516171819class A &#123; constructor() &#123; this.x = 1; &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; // code 1 // code 2 console.log(super.x); // undefined console.log(this.x); // 3 &#125;&#125;let b = new B(); super指向子类，如果通过super对某个属性赋值，super就是this，赋值的属性会变成子类实例的属性(code 1)。 在code 2中，对super进行对象访问，将会指向A.prototype，因此super.x为3。 Class 作为构造函数的语法糖，同时有prototype属性和proto属性，因此同时存在两条继承链。 123456class B extends A &#123; constructor() &#123; return A.call(this); //继承属性 &#125;&#125;A.prototype = new B; //继承方法 12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 子类B的proto属性指向父类A，子类B的prototype属性的proto属性指向父类A的prototype属性。 ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上；ES6 是先创建父类的实例对象this，然后再用子类的构造函数装饰this，使得父类的所有行为都可以继承。 123456789101112class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined mixin 将多个类的接口混入成为另一个类 12345678910111213141516171819202122function mix(...mixins) &#123; class Mix &#123;&#125; for (let mixin of mixins) &#123; copyProperties(Mix, mixin); // 拷贝实例属性 copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性 &#125; return Mix;&#125;function copyProperties(target, source) &#123; for (let key of Reflect.ownKeys(source)) &#123; if ( key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot; ) &#123; let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125;&#125; 这篇不错https://www.jianshu.com/p/342966fdf816","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"async 函数","date":"2018-01-16T13:48:50.000Z","path":"2018/01/16/async 函数/","text":"async函数是Generator的语法糖。利用Generator函数读取文件的操作为： 12345678910111213141516const fs = require(&apos;fs&apos;);const readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;const gen = function* () &#123; const f1 = yield readFile(&apos;/etc/fstab&apos;); const f2 = yield readFile(&apos;/etc/shells&apos;);&#125;;// 返回值是遍历器 同样，利用async函数实现则为： 12345const asyncReadFile = async function () &#123; const f1 = await readFile(&apos;/etc/fstab&apos;); const f2 = await readFile(&apos;/etc/shells&apos;);&#125;;返回值是Promise 在这里，利用async和await代替了*和yield，其中，async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。 1.基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName(&apos;goog&apos;).then(function (result) &#123; console.log(result);&#125;); 当异步操作完成之后，返回Promise对象，then方法来进行后续回调操作。 123456789101112function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint(&apos;hello world&apos;, 50); 50ms之后输出’hello world。但是async函数本身就可以返回Promise对象，可以作为await命令的参数，所以上例可以写为： 123456789101112async function timeout(ms) &#123; await new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;)&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint(&apos;hello world&apos;, 50); 1.1 async使用形式async函数有多种使用形式，一旦所有浏览器都可以用 async 函数的时候，甚至可以实现Async 一切！ （1）函数声明 1async function foo() &#123;&#125; （2）函数表达式 1const foo = async function() &#123;&#125;; （3）对象的方法 123let obj = &#123; async foo() &#123;&#125; &#125;;// obj.foo()返回promiseobj.foo().then(..); 例子： 12345678const storage = &#123; async getAvatar(name) &#123; const cache = await caches.open(&apos;avatars&apos;); return cache.match(`/avatars/$&#123;name&#125;.jpg`) &#125;&#125;storage.getAvatar(&apos;jaffathecake&apos;).then(...); （4）Class的方法 12345678910111213Class Storage &#123; constructor() &#123; this.cachePromise = caches.open(&apos;avatars&apos;); &#125; async getAvatar(name) &#123; const cache = await this.cachePromise; return cache.match(`/avatars/$&#123;name&#125;.jpg`); &#125;&#125;const storage = new Storage();storage.getAvatar(&apos;jaffathecake&apos;).then(); 注意： 类的构造函数和 getters/settings 不能是 async。 （5）箭头函数 12345// map some URLs to json-promisesconst jsonPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.json();&#125;); 注意：array.map(func) 并不在乎给它传的是 async 函数，它只是把它当做一个返回 promise 的函数。它在调用第二个函数之前并不会等待第一个函数完成。 1.2 async返回值在参考文章1中，Jake Archibald也提到的Async返回值： Async 函数总是会返回一个 promise，不管你是否用了 await。这个 promise 用 async 函数返回的任何值来resolve，或者用 async 函数抛出的任何值来reject。因此给定如下代码： 你 await（等待）的所有东西都是通过 Promise.resolve() 传递的，因此你可以安全地 await （等待）非本地的 promise。 12345678910// 代码段1function wait(ms) &#123; // Promise接收一个函数作为参数，函数的参数默认第一个为resolve回调，第二个为reject（本例中忽略了reject） return new Promise(r =&gt; setTimeout(r, ms));&#125;async function hello() &#123; await wait(500); return &apos;world&apos;;&#125; 调用 hello() 会返回一个用 “world” 来完成的 promise。 async函数内部return语句返回的值，会成为then方法回调函数的参数。 1234// 调用代码段1中的hellohello().then(res =&gt; console.log(res));// world async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。 1234async function foo() &#123; await wait(500); throw Error(&apos;bar&apos;);&#125; 调用 foo() 会返回一个用 Error(‘bar’) 来拒绝的 promise。 12345foo.then( v =&gt; console.log(v), err =&gt; console.log(err))// Error: bar async then方法最后执行（所有异步操作之后）。 1.3 await命令await命令后面是一个Promise对象，如果不是，会被转成一个立即resolve的Promise对象。 123456async function f() &#123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123 如下情况：await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。 1234567async function f() &#123; await Promise.reject(&apos;出错了&apos;);&#125;f().then(v =&gt; console.log(v)) .catch(err =&gt; console.log(err))// 出错了 await语句后方的Promisre变为reject则reject参数会被cache回调函数接收到，一旦有一个异步操作出错就会中断进入catch。如果所有await操作均为为resolve则被then处理，async then方法最后执行（所有异步操作之后）。 1234async function f() &#123; await Promise.reject(&apos;出错了&apos;); await Promise.resolve(&apos;hello world&apos;); // 不会执行&#125; 在不希望前面的异步操作失败导致后续异步操作中断的情况下，一般有以下两种解决办法： （1）使用try-catch结构，将第一个await放到try…catch结构里面，这样无论第一个是否成功，第二个均会执行。 1234567891011async function f() &#123; try &#123; await Promise.reject(&apos;出错了&apos;); &#125; catch(e) &#123; &#125; return await Promise.resolve(&apos;hello world&apos;);&#125;f().then(v =&gt; console.log(v))// hello world (2) 在await后面跟一个单独的catch方法，处理可能的错误。 12345678910async function f() &#123; await Promise.reject(&apos;出错了&apos;) .catch(e =&gt; console.log(e)); return await Promise.resolve(&apos;hello world&apos;);&#125;f().then(v =&gt; console.log(v))// 出错了// hello world 1.4 错误处理将异步操作放到try…catch代码块之中： 123456789101112async function main() &#123; try &#123; const val1 = await firstStep(); const val2 = await secondStep(val1); const val3 = await thirdStep(val1, val2); console.log(&apos;Final: &apos;, val3); &#125; catch (err) &#123; console.error(err); &#125;&#125; 本节的学习可以参考下从不用 try-catch 实现的 async/await 语法说错误处理。 1.5 使用注意点（1）await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。无论是使用try-catch代码块还是在await后添加.catch方法均可。 （2）多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 12let foo = await getFoo();let bar = await getBar(); getFoo与getBar是相互独立的异步操作，被写成了继发的关系。只有getFoo完成后，才会执行getBar，但是事实上两者可以同时触发，节省耗时。 同时触发多个异步操作的方式有两种： 123456789// 方法1let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 方法2// 先启用两个Promise再把他们放到await等待队列中let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 使用用例（合法性检测）： 12345async function checkAllValid(urls) &#123; const data = await Promise.all(urls.map(url =&gt; checkValid(url))); return data;&#125; （3）await命令只能用在async函数之中，如果用在普通函数，就会报错。这一点与generator函数相同。(async慎用forEach) 12345678async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 报错 docs.forEach(function (doc) &#123; await db.post(doc); &#125;);&#125; 上面await放在forEach中就会报错，需要把forEach的方法参数改为async函数 12345678async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 报错 docs.forEach(async function (doc) &#123; await db.post(doc); &#125;);&#125; 上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。 1234567async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; for (let doc of docs) &#123; await db.post(doc); &#125;&#125; 如果确实希望多个请求并发执行，可以使用Promise.all方法。当三个请求都会resolved时，下面两种写法效果相同。 @std/esm模块加载器支持顶层await，await命令可以不放在async函数里面直接使用。 1234567891011// async 函数写法const start = async () =&gt; &#123; const res = await fetch(&apos;google.com&apos;); return res.text();&#125;start().then(console.log);// 顶层 await 的写法const res = await fetch(&apos;google.com&apos;);console.log(await res.text()); 2. 原理async就是将Generator函数和自动执行器，包装在一个函数中。 1234567891011async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function* () &#123; // ... &#125;);&#125; 其中spawn为自动执行器。实现如下： 12345678910111213141516171819202122232425262728293031// 传入Generator函数function spawn(genF) &#123; // 返回一个Promise return new Promise(function(resolve, reject) &#123; // 获取遍历器（指针） const gen = genF(); // 定义step函数，传入回调函数 function step(nextF) &#123; let next; try &#123; next = nextF(); &#125; catch(e) &#123; return reject(e); &#125; if(next.done) &#123; return resolve(next.value); &#125; // Promise.resolve可以将现有next.value转为Promise对象 Promise.resolve(next.value).then(function(v) &#123; step(() =&gt; gen.next(v)); &#125;, function(e) &#123; step(() =&gt; gen.throw(e)); &#125;); &#125; // 执行step，gen.next递归 step(() =&gt; gen.next(undefined)); &#125;);&#125; 例子： 123456789101112function fn(args) &#123; return spawn(function* () &#123; const f1 = yield readFile(&apos;/etc/fstab&apos;); const f2 = yield readFile(&apos;/etc/shells&apos;); &#125;)&#125;// 等同于：async function foo() &#123; const f1 = await readFile(&apos;/etc/fstab&apos;); const f2 = await readFile(&apos;/etc/shells&apos;);&#125; 3. 避免过度强制先后顺序不要因为想同步就错过并行处理的机会， 12345async function series() &#123; await wait(500); await wait(500); return &quot;done!&quot;;&#125; 执行需要1000ms，但是改为： 1234567async function parallel() &#123; const wait1 = wait(500); const wait2 = wait(500); await wait1; await wait2; return &quot;done!&quot;;&#125; 以上代码 500 毫秒完成，因为两个 wait 是同时发生的。让我们看看一个实际的例子。 例子：按顺序输出 fetch假设：我们想获取一系列的 URL 并尽快地按正确的顺序记录下来。 如果用Promise实现： 123456789101112function logInOrder(urls) &#123; // fetch all the URLs const textPromises = urls.map(url =&gt; &#123; return fetch(url).then(response =&gt; response.text()); &#125;); // log them in order textPromises.reduce((chain, textPromise) =&gt; &#123; return chain.then(() =&gt; textPromise) .then(text =&gt; console.log(text)); &#125;, Promise.resolve());&#125; 这段代码会让程序变得看起来很高级，转成async发现，以上代码难以读懂的同时又过分强制了执行顺序： 123456async function logInOrder(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125; 这段代码中，第二次获取要等到第一次获取读取完毕才开始，执行效率低于其他并行获取的Promise示例。 推荐的并行写法是： 123456789101112async function logInOrder(urls) &#123; // fetch all the URLs in parallel const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // log them in sequence for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125; 这种，类似于算法中递归与查找（匹配）同时存在时，最好先进行完递归，得到符合条件的数据之后，再遍历进行查找是类似的思想。URL 是并行获取和读取的，但是“所谓聪明的” reduce 被一个标准的、枯燥的、可读性好的 for 循环取代了。 4. 对比其他异步方法async 函数与 Promise、Generator 函数的比较 假设：某个DOM元素上部署了一系列动画，这些动画顺序执行，前一个动画结束之后，后一个动画才可以开始。一旦出错，不再继续执行，返回最后一个成功执行动画的返回值。 Promise写法如下： 12345678910111213141516171819202122232425/** * @params elem DOM元素**/funcion chainAnimationPromise(elem, animations) &#123; // 变量ret用来保存上一个动画的返回值 let ret = null; // 新建一个空的Promise let p = Promise.resolve(); // 使用then方法，添加所有动画 for(let anim of animations) &#123; p = p.then(function(val) &#123; ret = val; return anim(elem); &#125;); &#125; // 返回一个部署了错误捕捉机制的Promise return p.catch(function(e) &#123; /* 忽略错误，继续执行 */ &#125;).then(function() &#123; return ret; &#125;);&#125; Promise写法代码语义不明。下面是Generator实现： 123456789101112131415function chainAnimationsGenerator(elem, animations) &#123; return spawn(function*() &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = yield anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret; &#125;);&#125; spawn为上文所述的自动执行函数，用户定义的操作在spawn函数的内部。而且必须保证yield语句后面的表达式，必须返回一个 Promise。 async 函数的写法： 1234567891011async function chainAnimationsAsync(elem, animations) &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = await anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret;&#125; 最为简洁，符合语义。将Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。 5. 异步遍历器《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的next方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。next方法返回的对象的结构是{value, done}，其中value表示当前的数据的值，done是一个布尔值，表示遍历是否结束。 这里隐含着一个规定，next方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行next方法，就必须同步地得到value和done这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。 目前的解决方法是，Generator 函数里面的异步操作，返回一个 Thunk 函数或者 Promise 对象，即value属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而done属性则还是同步产生的。 目前，有一个提案，为异步操作提供原生的遍历器接口，即value和done这两个属性都是异步产生，这称为”异步遍历器“（Async Iterator）。 5.1 异步遍历器接口异步遍历器的最大的语法特点，就是调用遍历器的next方法，返回的是一个 Promise 对象，可以不断的进行then方法和next调用返回每一个异步操作的结果。 12345678910111213141516const asyncIterable = createAsyncIterable([&apos;a&apos;, &apos;b&apos;]);const asyncIterator = asyncIterable[Symbol.asyncIterator]();asyncIterator.next().then(iterResult1 =&gt; &#123; console.log(iterResult1); // &#123; value: &apos;a&apos;, done: false &#125; return asyncIterator.next();&#125;).then(iterResult2 =&gt; &#123; console.log(iterResult2); // &#123; value: &apos;b&apos;, done: false &#125; return asyncIterator.next();&#125;).then(iterResult3 =&gt; &#123; console.log(iterResult3); // &#123; value: undefined, done: true &#125;&#125;); 返回的是Promise对象，因此可以放在await命令后面。 12345678910async function f() &#123; const asyncIterable = createAsyncIterable([&apos;a&apos;, &apos;b&apos;]); const asyncIterator = asyncIterable[Symbol.asyncIterator](); console.log(await asyncIterator.next()); // &#123; value: &apos;a&apos;, done: false &#125; console.log(await asyncIterator.next()); // &#123; value: &apos;b&apos;, done: false &#125; console.log(await asyncIterator.next()); // &#123; value: undefined, done: true &#125;&#125; 也可以使用Promise.all(常用)：123456const asyncGenObj = createAsyncIterable([&apos;a&apos;, &apos;b&apos;]);const [&#123;value: v1&#125;, &#123;value: v2&#125;] = await Promise.all([ asyncGenObj.next(), asyncGenObj.next()]);console.log(v1, v2); // a b 5.2 for await of下面这段代码，createAsyncIterable()返回一个异步遍历器，for…of循环自动调用这个遍历器的next方法，会得到一个 Promise 对象。await用来处理这个 Promise 对象，一旦resolve，就把得到的值（x）传入for…of的循环体。 1234567async function f() &#123; for await (const x of createAsyncIterable([&apos;a&apos;, &apos;b&apos;])) &#123; console.log(x); &#125;&#125;// a// b 5.3 异步Generator异步 Generator 函数就是async函数与 Generator 函数的结合。 例子： 1234567async function* gen() &#123; yield &apos;hello&apos;;&#125;const genObj = gen();genObj.next().then(x =&gt; console.log(x)); gen是一个异步 Generator 函数，执行后返回一个异步 Iterator 对象。对该对象调用next方法，返回一个 Promise 对象。 5.4 yield* 语句yield*语句也可以跟一个异步遍历器。 12345678910async function* gen1() &#123; yield &apos;a&apos;; yield &apos;b&apos;; return 2;&#125;async function* gen2() &#123; // result 最终会等于 2 const result = yield* gen1();&#125; 上面代码中，gen2函数里面的result变量，最后的值是2。 与同步 Generator 函数一样，for await…of循环会展开yield*。 1234567(async function () &#123; for await (const x of gen2()) &#123; console.log(x); &#125;&#125;)();// a// b 参考 异步（Async 函数) ——提高 Promise 的易用性 从不用 try-catch 实现的 async/await 语法说错误处理 分析了Dima 的错误处理方式，不用try-catch与使用try-catch","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Generator应用","date":"2018-01-10T13:48:50.000Z","path":"2018/01/10/Generator应用/","text":"协同，流程控制 1. 与Thunk函数实现流程管理现有thunkify模块，与generator共同配合、如下： 12345678910111213141516171819202122var fs = require('fs');var thunkify = require('thunkify');var readFileThunk = thunkify(fs.readFile);var gen = function* ()&#123; var r1 = yield readFileThunk('/etc/fstab'); console.log(r1.toString()); var r2 = yield readFileThunk('/etc/shells'); console.log(r2.toString());&#125;;var g = gen();var r1 = g.next();r1.value(function (err, data) &#123; if (err) throw err; var r2 = g.next(data); r2.value(function (err, data) &#123; if (err) throw err; g.next(data); &#125;);&#125;); Generator 函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。 g作为一个流程控制指针（ Generator 函数的内部指针），表示函数执行到了哪一步。 2. Co模块可以实现自动流程控制的除了Thunk函数，还有Promise对象。co模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。 使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数（co v4.0之后不能为Thunk函数）或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用co。 2.1 co的基本用法1234567891011var co = require(&apos;co&apos;);var gen = function* () &#123; var f1 = yield readFile(&apos;/etc/fstab&apos;); var f2 = yield readFile(&apos;/etc/shells&apos;); console.log(f1.toString()); console.log(f2.toString());&#125;;co(gen);// Generator 函数只要传入co函数，就会自动执行 此外，co本身会返回一个Promise对象，因此可以对CO,也就是自动执行的整个流程添加回调函数： 123co(gen).then(function ()&#123; console.log(&apos;Generator 函数执行完成&apos;);&#125;); 等到 Generator 函数执行结束，就会输出一行提示。 2.2 co模块原理co4.0之前是用thunk实现的，之后是用promise实现的. 需要了解Thunk 函数的自动执行器与Promise 对象的自动执行器。 （1）基于Promise 对象的自动执行器首先，把fs模块的readFile方法包装成一个 Promise 对象： 123456789101112131415var fs = require(&apos;fs&apos;);var readFile = function (fileName)&#123; return new Promise(function (resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;var gen = function* ()&#123; var f1 = yield readFile(&apos;/etc/fstab&apos;); var f2 = yield readFile(&apos;/etc/shells&apos;);&#125;; 手动执行Generator函数gen的操作入下，其实就是用then方法，层层添加回调函数。 1234567var g = gen(); // 遍历器g.next().value.then(function(data)&#123; g.next().value.then(function(data)&#123; g.next(); &#125;);&#125;） 这个过程用自动执行器替代就是： 123456789101112131415function run(gen) &#123; var g = gen(); function next(data) &#123; var result = g.next(data); if (result.done) return result.value; result.value.then((data)=&gt; &#123; next(data); &#125;); &#125; next();&#125;run(gen); (2) co模块源码分析co的源码只有两百行，地址https://github.com/tj/co/blob/master/index.js co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100function co(gen) &#123; var ctx = this; return new Promise((resolve, reject) =&gt; &#123; // 是否为generator函数，如果是就执行gen，获取遍历器（内部指针对象） if (typeof gen === &apos;function&apos;) gen = gen.call(ctx); // 如果不是就返回，并将状态置为resolved if (!gen || typeof gen.next !== &apos;function&apos;) return resolve(gen); // 入口 onFulfilled(); /** * @param &#123;Mixed&#125; res * @return &#123;Promise&#125; * @api private * @desc 成功状态下的回调函数 */ function onFulfilled(res) &#123; // 将遍历器g的next方法封装成onFulfilled，以便错误捕获。 var ret; try &#123; ret = gen.next(res); // 指向下一个 &#125; catch (e) &#123; return reject(e); &#125; next(ret); // 将结果传入自定义的next方法 &#125; // reject状态下的回调函数 function onRejected(err) &#123; var ret; try &#123; ret = gen.throw(err); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; // 通过next来实现递归操作，反复调用自身 function next(ret) &#123; // 如果执行完成，直接调用resolve把promise置为成功状态 if (ret.done) return resolve(ret.value); // 把yield的值转换成promise var value = toPromise.call(ctx, ret.value); // 成功转换就可以直接给新的promise添加onFulfilled, onRejected。当新的promise状态变成结束态（成功或失败）。就会调用对应的回调。整个next链路就执行下去了。 if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); // 格式不符合要求，将Promise状态置为rejected return onRejected( new TypeError( &apos;You may only yield a function, promise, generator, array, or object, &apos; + &apos;but the following object was passed: &quot;&apos; + String(ret.value) + &apos;&quot;&apos; ) ) &#125; &#125;) // 支持 promise，generator，generatorFunction，array，object function toPromise(obj) &#123; if (!obj) return obj; if (isPromise(obj)) return obj; if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj); if (&apos;function&apos; == typeof obj) return thunkToPromise.call(this, obj); if (Array.isArray(obj)) return arrayToPromise.call(this, obj); if (isObject(obj)) return objectToPromise.call(this, obj); return obj; &#125; // 更严谨的判断可以看https://github.com/then/is-promise/blob/master/index.js function isPromise(obj) &#123; return &apos;function&apos; == typeof obj.then; &#125; function isGeneratorFunction(obj) &#123; var constructor = obj.constructor; if (!constructor) return false; if (&apos;GeneratorFunction&apos; === constructor.name || &apos;GeneratorFunction&apos; === constructor.displayName) return true; return isGenerator(constructor.prototype); &#125; function isGenerator(obj) &#123; return &apos;function&apos; == typeof obj.next &amp;&amp; &apos;function&apos; == typeof obj.throw; &#125; function thunkToPromise(fn) &#123; var ctx = this; return new Promise(function (resolve, reject) &#123; fn.call(ctx, function (err, res) &#123; if (err) return reject(err); if (arguments.length &gt; 2) res = slice.call(arguments, 1); resolve(res); &#125;); &#125;); &#125; ...&#125; (3) 处理并发的异步操作co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。 这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。 1234567891011121314151617// 数组的写法co(function* () &#123; var res = yield [ Promise.resolve(1), Promise.resolve(2) ]; console.log(res);&#125;).catch(onerror);// 对象的写法co(function* () &#123; var res = yield &#123; 1: Promise.resolve(1), 2: Promise.resolve(2), &#125;; console.log(res);&#125;).catch(onerror); 或者123456789co(function* () &#123; var values = [n1, n2, n3]; yield values.map(somethingAsync);&#125;);function* somethingAsync(x) &#123; // do something async return y&#125; 允许并发三个异步操作somethingAsync，全部完成之后进行下一步。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Promise笔记","date":"2017-12-14T13:48:50.000Z","path":"2017/12/14/Promise/","text":"Promise可以将异步操作以同步操作的流程表达出来Promise新建后会立即执行。12345678910let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!'); 输出顺序为：123// Promise// Hi!// resolved then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 Promise 状态已经变成resolved，再抛出错误是无效的，链式操作catch不到. Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。1234567891011121314151617// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;);// 因为catch不仅能捕获promise的错误，还可以捕获前面的then方法执行的错误，所以不使用then方法的第二个参数 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。123456789101112setTimeout(function () &#123; console.log('three');&#125;, 0);Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(‘one’)则是立即执行，因此最先输出。 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是”可遍历的“（iterable）。 ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable） next方法的参数表示上一个yield表达式的返回值","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"LESS笔记","date":"2017-10-06T13:48:50.000Z","path":"2017/10/06/Less笔记/","text":"1. 变量less变量名使用@标记，例如： 123456@nice-blue: #5B83AD;@PingFangSC-Regular: Tahoma, &apos;PingFangSC-Regular&apos;, &apos;Microsoft YaHei&apos;, &apos;Myriad Pro&apos;, &apos;Hiragino Sans GB&apos;, &quot;Lucida Grande&quot;, sans-serif;#header &#123; color: @light-blue;&#125; 1.1 可变差值12345678@mySelector: banner;// Usage.@&#123;mySelector&#125; &#123; font-weight: bold; line-height: 40px; margin: 0 auto;&#125; 1.2 插入url12345@images: &quot;../img&quot;;body &#123; color: #444; background: url(&quot;@&#123;images&#125;/white-sand.png&quot;);&#125; 1.3 插入表达式12345// Variables@themes: &quot;../../src/themes&quot;;// Usage@import &quot;@&#123;themes&#125;/tidal-wave.less&quot;; 1.4 属性123456@property: color;.widget &#123; @&#123;property&#125;: #0ee; background-@&#123;property&#125;: #999;&#125; 1.5 Lazy Loading 变量是懒加载（惰性加载）的，不一定要在使用前的位置进行声明。 如第7节的例子。 变量被定义了两次时，会使用最后一次被定义的值（作用域自下而上）。这和CSS本身有点类似，在css中当同一个属性定义了两次，会使用最后一次定义。 例如： 12345678910@var: 0;.class1 &#123; @var: 1; .class &#123; @var: 2; three: @var; @var: 3; &#125; one: @var;&#125; 将会被编译为 123456.class1 .class &#123; three: 3;&#125;.class &#123; one: 1;&#125; 1.6 默认变量在varibals.less文件中，我们可能会定义一系列的变量，有些需要接收其他变量作为参数。这时，为了防止出错，可以在varibals.less文件中定义相应的默认变量。 例如：1234567// library@base-color: green;@dark-color: darken(@base-color, 10%);// use of library@import &quot;library.less&quot;;@base-color: red; 最终，base-color会被调用处的覆盖，@dark-color为深红色。 2. Mixin在一些地方有可能想把之前写的样式直接加到其他元素上时，可以使用mixin： 12345678910111213141516171819202122232425.display-flex()&#123; display: -webkit-box; /* Chrome 4+, Safari 3.1, iOS Safari 3.2+ */ display: flex; /* Chrome 29+, Firefox 22+, IE 11+, Opera 12.1/17/18, Android 4.4+ */&#125;.example &#123; color: @nice-blue; .display-flex();&#125;.bordered &#123; border-top: dotted 1px black; border-bottom: solid 2px black;&#125;#menu a &#123; color: #111; .bordered;&#125;.post a &#123; color: red; .bordered;&#125; display-flex和bordered都通过mixin使用。 2.1 不输出混合集本身如果你想要创建一个混合集，但是却不想让它输出到你的样式中，你可以在混合集的名字后面加上一个括号。 1234567891011.my-mixin &#123; color: black;&#125;// 混合集，只使用，不单独输出.my-other-mixin() &#123; background: white;&#125;.class &#123; .my-mixin; .my-other-mixin;&#125; 输出： 1234567.my-mixin &#123; color: black;&#125;.class &#123; color: black; background: white;&#125; 2.2 带选择器的混合集混合集不仅可以包含各种属性，而且可以包括各种选择器。 12345678.my-hover-mixin() &#123; &amp;:hover &#123; border: 1px solid red; &#125;&#125;button &#123; .my-hover-mixin();&#125; 输出： 123button:hover &#123; border: 1px solid red;&#125; 2.3 Namespace通过Namespace可以给变量或mixin分组，还可以通过Namespace调用其他mixin： 如下是一个#bundle选择器，选择器中定义了button样式： 123456789101112#bundle &#123; .button &#123; display: block; border: 1px solid black; background-color: grey; &amp;:hover &#123; background-color: white &#125; &#125; .tab &#123; ... &#125; .citation &#123; ... &#125;&#125; 如果在其他地方想要复用button样式，例如在一个#header a选择器中，可以通过#bundle &gt; .button来使用，也可以是#bundle &gt; .button、#bundle.button或者#bundle.button()，这几种效果相同。 1234#header a &#123; color: orange; #bundle &gt; .button;&#125; 2.4 !important关键字在混合集的调用处后面添加!important关键字，可以使混合集里面的所有属性都继承 !important： 例如： 12345678910.foo (@bg: #f5f5f5, @color: #900) &#123; background: @bg; color: @color;&#125;.unimportant &#123; .foo();&#125;.important &#123; .foo() !important;&#125; 输出： 12345678.unimportant &#123; background: #f5f5f5; color: #900;&#125;.important &#123; background: #f5f5f5 !important; color: #900 !important;&#125; 2.5 带参数的mixin mixins也可以接受参数，在它进行mix in操作时会将变量传递给选择器代码块 123456789101112.border-radius(@radius: 5px) &#123; -webkit-border-radius: @radius; -moz-border-radius: @radius; border-radius: @radius;&#125;#header &#123; .border-radius(4px);&#125;.button &#123; .border-radius(6px);&#125; @radius: 5px 表示默认值为5px。 emmm…，这是个例子，然鹅我们一般写的时候直接用Postcss自动补齐前缀。但是在很多场景下，传参数是很方便的。 2.6 带多个参数的mixins参数可以用分号或者逗号分割。但是推荐使用分号分割。因为逗号符号有两个意思：它可以解释为mixins参数分隔符或者css列表分隔符。 两个参数，并且每个参数都是逗号分割的列表：.name(1,2,3;something, ele)， 三个参数，并且每个参数都包含一个数字：.name(1,2,3)， 使用伪造的分号创建mixin，调用的时候参数包含一个逗号分割的css列表：.name(1,2,3;)， 逗号分割默认值：.name(@param1: red, blue)。 定义多个具有相同名称和参数数量的mixins是合法的。Less会使用它可以应用的属性。如果使用mixin的时候只带一个参数，比如.mixin(green)，这个属性会导致所有的mixin都会使用强制使用这个明确的参数： 123456789101112131415.mixin(@color) &#123; color-1: @color;&#125;.mixin(@color; @padding: 2) &#123; color-2: @color; padding-2: @padding;&#125;.mixin(@color; @padding; @margin: 2) &#123; color-3: @color; padding-3: @padding; margin: @margin @margin @margin @margin;&#125;.some .selector div &#123; .mixin(#008000);&#125; 会编译为： 12345.some .selector div &#123; color-1: #008000; color-2: #008000; padding-2: 2;&#125; 如果调用时通过参数名来引用，不用在意参数传入的顺序： 1234567891011.mixin(@color: black; @margin: 10px; @padding: 20px) &#123; color: @color; margin: @margin; padding: @padding;&#125;.class1 &#123; .mixin(@margin: 20px; @color: #33acfe);&#125;.class2 &#123; .mixin(#efca44; @padding: 40px);&#125; 会编译为： 12345678910.class1 &#123; color: #33acfe; margin: 20px; padding: 20px;&#125;.class2 &#123; color: #efca44; margin: 10px; padding: 40px;&#125; 3. 嵌套less、sass等都是支持嵌套的，这样一定程度上也可以减少全局污染。嵌套写法中，获取当前嵌套父元素的方法是使用 &amp;，经常和:hover、:after等伪元素、伪类一起使用。 123456789101112131415161718192021a &#123; color: blue;&#125;a:hover &#123; color: green;&#125;// 相同前缀button-*.button &#123; &amp;-ok &#123; background-image: url(&quot;ok.png&quot;); &#125; &amp;-cancel &#123; background-image: url(&quot;cancel.png&quot;); &#125; &amp;-custom &#123; background-image: url(&quot;custom.png&quot;); &#125;&#125; &amp;代表了所有的父级元素选择器，而不是最近的： 12345678910111213141516171819202122232425262728293031323334.grand &#123; .parent &#123; &amp; &gt; &amp; &#123; color: red; &#125; &amp; &amp; &#123; color: green; &#125; &amp;&amp; &#123; color: blue; &#125; &amp;, &amp;ish &#123; color: cyan; &#125; &#125;&#125;// output.grand .parent &gt; .grand .parent &#123; color: red;&#125;.grand .parent .grand .parent &#123; color: green;&#125;.grand .parent.grand .parent &#123; color: blue;&#125;.grand .parent,.grand .parentish &#123; color: cyan;&#125; 在这里，&amp;代表了.grand .parent。 &amp;还可以改变选择器顺序： 12345678.header &#123; .menu &#123; border-radius: 5px; .no-borderradius &amp; &#123; background-image: url(&apos;images/button-background.png&apos;); &#125; &#125;&#125; no-borderradius 后面跟了 &amp;，输出将会被编译为： 123456.header .menu &#123; border-radius: 5px;&#125;.no-borderradius .header .menu &#123; background-image: url(&apos;images/button-background.png&apos;);&#125; &amp; 还可以组合排列逗号分隔的选择器： 123456p, a, ul, li &#123;border-top: 2px dotted #366; &amp; + &amp; &#123; border-top: 0; &#125;&#125; 转义后有16种组合： 123456789101112131415161718192021222324p,a,ul,li &#123; border-top: 2px dotted #366;&#125;p + p,p + a,p + ul,p + li,a + p,a + a,a + ul,a + li,ul + p,ul + a,ul + ul,ul + li,li + p,li + a,li + ul,li + li &#123; border-top: 0;&#125; 4. 运算任何数字、颜色或者变量都可以参与运算。 1234567@base: 5%;@filler: @base * 2;@other: @base + @filler;color: #888 / 4;background-color: @base-color + #111;height: 100% / 2 + @filler; Less 将会使用出现的单位，在这个例子中，最终输出是 6px。 1@var: 1px + 5; 5. 函数Less内置了很多函数，关于算数运算、转换颜色、处理字符串等。 percentage: 将0.5转化为50%；saturate: 颜色饱和度增加 5%lighten: 颜色亮度降低 25%spin: 色相值增加 8 12345678@base: #f04615;@width: 0.5;.class &#123; width: percentage(@width); // returns `50%` color: saturate(@base, 5%); background-color: spin(lighten(@base, 25%), 8);&#125; 6. Namespace通过Namespace可以给变量或mixin分组，还可以通过Namespace调用其他mixin： 如下是一个#bundle选择器，选择器中定义了button样式： 123456789101112#bundle &#123; .button &#123; display: block; border: 1px solid black; background-color: grey; &amp;:hover &#123; background-color: white &#125; &#125; .tab &#123; ... &#125; .citation &#123; ... &#125;&#125; 如果在其他地方想要复用button样式，例如在一个#header a选择器中，可以通过#bundle &gt; .button来使用，也可以是#bundle &gt; .button、#bundle.button或者#bundle.button()，这几种效果相同。 1234#header a &#123; color: orange; #bundle &gt; .button;&#125; 7. Scope(作用域)像js等语言一样，less会有作用域，先在本地查找变量或函数，若无逐层向上查找。 12345678@var: red;#page &#123; @var: white; #header &#123; color: @var; // white &#125;&#125; 而且，变量和mixin在使用之前不必声明，所以下面的Less代码和前面的例子是一样的： 12345678@var: red;#page &#123; #header &#123; color: @var; // white &#125; @var: white;&#125; 8. 注释块注释和行注释都可以使用： 123456/* 一个注释块style comment! */@var: red;// 这一行被注释掉了！@var: white; 9. 导入可以导入.less 文件，此文件中的所有变量就可以全部使用了。如果导入的文件是 .less 扩展名，则可以将扩展名省略掉： 12@import &quot;library&quot;; // library.less@import &quot;typo.css&quot;; 一般需要导入的文件有mixin、varibals、base等，不会污染全局样式的公共变量、函数定义、初始化。 10. Extend扩展 extend是一个Less伪类，会合并他所在的选择器和它所匹配的引用 例如： 1234567nav ul &#123; &amp;:extend(.inline); background: blue;&#125;.inline &#123; color: red;&#125; 编译输出： 1234567nav ul &#123; background: blue;&#125;.inline,nav ul &#123; color: red;&#125; 10.1 Extend “all”当你在extend参数的最后面指定all关键字时，它会告诉告诉匹配作为其他选择器一部分的选择器。这个选择器会被复制，然后匹配的选择器部分会使用扩展替换，创建一个新的选择器。 1234567891011.a.b.test,.test.c &#123; color: orange;&#125;.test &#123; &amp;:hover &#123; color: green; &#125;&#125;.replacement:extend(.test all) &#123;&#125; 输出 12345678910.a.b.test,.test.c,.a.b.replacement,.replacement.c &#123; color: orange;&#125;.test:hover,.replacement:hover &#123; color: green;&#125; 可以认为是一种 无损搜索和替换。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"完美底部","date":"2017-09-06T13:48:50.000Z","path":"2017/09/06/【css复习】完美底部/","text":"实现一个完美底部：当页面内容不能铺满全屏时，footer固定于屏幕最下方，当内容超出全屏出现滚动条时，footer在内容的最下方。 这怕是我们写pc端或是移动端页面经常遇到的问题了，其实每次都可以写出，但是没有进行总结，在这里总结以下几种方法。 方法一对footer使用position:absolute，bottom为0，页面整体wrapper用wrapper嵌套，并设置min-height为100%（IE6下为height:100%）。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;完美底部&lt;/title&gt; &lt;style type=\"text/css\"&gt; html, body &#123; height: 100%; padding: 0; margin: 0; &#125; #wrapper &#123; min-height: 100%; /* 最低为100% */ height: auto; position: relative; &#125; .header &#123; height: 80px; background:#ff0; &#125; .container &#123; background: pink; &#125; .footer &#123; position: absolute; background:#6cf; height: 60px; width: 100%; bottom: 0; /*绝对定位，位于底部*/ left: 0; &#125; &lt;/style&gt; &lt;!--[if IE 6]-&gt; &lt;style type=\"text/css\"&gt; #wrapper &#123; height: 100%; &#125; &lt;/style&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"wrapper\"&gt; &lt;div class=\"header\"&gt;header&lt;/div&gt; &lt;div class=\"container\"&gt;123&lt;/div&gt; &lt;div class=\"footer\"&gt;footer&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; PC端亲测有效。 2. 方法二使用flex布局。1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;完美底部——flex&lt;/title&gt; &lt;style type=\"text/css\"&gt; html &#123; height: 100%; &#125; body &#123; display: flex; flex-direction: column; padding: 0; margin: 0; height: 100%; &#125; header &#123; height: 80px; background:#ff0; &#125; .main &#123; flex: 1; background: pink; overflow: auto; &#125; footer &#123; background:#6cf; height: 60px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;header&lt;/header&gt; &lt;div class=\"main\"&gt;main &lt;div style=\"height: 1000px;\"&gt;内部&lt;/div&gt; &lt;/div&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"关于this","date":"2017-09-04T06:08:03.000Z","path":"2017/09/04/关于this/","text":"作用域分为两种： 1. 词法作用域，2. 动态作用域。javascript遵循词法作用域，闭包等概念也是由词法作用域衍生而来。而this是js中一个特别的关键字，被自动定义在所有函数的作用域中。 动态作用域其实是this的表亲，this机制也没有想象中那么复杂，在缺乏清楚认识的情况下，this的结果才会会有些出乎意料。 误区一12345678910111213141516function foo(num) &#123; console.log('foo: ' + num); this.count++; // console.log(this.count) // NaN&#125;foo.count = 0;var i = 0;for (i = 0; i &lt; 10; i++) &#123; if (i &gt; 5) &#123; // 如果调用时只用foo(i),最后输出count为0 foo(i); // foo.call(foo, i); &#125;&#125;console.log(foo.count); 原意为使用count记录foo的调用次数，但是当前的结果却是：12345foo: 6foo: 7foo: 8foo: 90 // ??? 当在foo中打印this.count时，发现count为NaN。而且调试发现，这是一个全局变量。 为什么这是全局变量？为什么这是NaN？ 解决办法 循环中使用foo.call(foo, i);，确保this指向函数对象foo本身 使用 foo.count++;回归词法作用域 另一个误区12345678910function foo() &#123; var a = 2; this.bar();&#125;function bar() &#123; console.log(this.a);&#125;foo(); 在这里利用了this来隐式的引用函数的词法作用域。试图通过this.bar()引用bar函数（这里能调用成功也只是个意外——this指向window），还试图通过this联通foo和bar的作用域，从而使bar可以访问a，然而失败了。 this解析学习this，需要明确每个函数的调用栈，即调用位置。调用位置和调用方式决定了this的绑定对象。this有以下几种绑定规则： 1. 默认绑定-独立函数调用123456function foo() &#123; console.log(this.a);&#125;var a = 2;foo(); // 2 这里foo的调用未使用任何修饰，因此被进行了默认绑定。非严格模式下，this.a被解析为全局变量a。（严格模式下会报错TypeError） 2. 隐式绑定调用位置是否有上下文对象，即foo函数式通过哪个对象来调用的。这种情况下，绑定的对象必须包含一个指向函数的属性。12345678910function foo() &#123; console.log(this.a);&#125;var obj1 = &#123; a: 2, foo: foo&#125;obj1.foo(); // 2 这种绑定只与属性引用链的上一层或者最后一层有关，如下：123456789101112131415function foo() &#123; console.log(this.a);&#125;var obj2 = &#123; a: 22, foo: foo&#125;var obj1 = &#123; a: 2, obj2: obj2&#125;obj1.obj2.foo(); // 22 隐式丢失隐式绑定的函数会丢失绑定对象，转而遵循默认绑定，从而把this绑定到全局对象或者undefined上（非严格模式）。12345678910111213function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;var bar = obj.foo;var a = 'global , oops';bar(); // 'global , oops' bar指向了foo，bar的调用不带任何修饰。因此抛出结果与默认绑定一致。此外，若作为参数传入函数也会发生同样的事情，因为函数的参数处理js引擎默认进行了LHS查询赋值，获取到的也是foo函数的引用:123456789101112131415function foo() &#123; console.log(this.a);&#125;function doFoo(fn) &#123; fn();&#125;var obj = &#123; a: 2, foo: foo&#125;var a = 'global , oops';doFoo(obj.foo); // 'global , oops' 同理，回调函数中丢失this绑定，也是最常见的。我们通常采取的解决办法是： 将setTimeout或者请求、监听中的回调函数进行bind(this)，绑定当前作用域的this（硬绑定）; 或者采取别名保存self=this，借助词法作用域进行访问; 使用ES6的箭头函数，它没有自己的 this 、直接继承外部作用域的this; 3. 显示绑定显示绑定大多数情况下是硬绑定，还有一些第三方库或者框架提供的用于绑定的API。这里只分析硬绑定相关。 其实硬绑定就是通过我们同通常接触到的call、apply、bind 在第一个误区例子中，我们可以使用foo.call(foo,i)就是使用了硬绑定，来解决默认绑定带来的问题。应用场景1： 创建包裹函数，负责接收参数并返回值。123456789101112131415function foo(something) &#123; console.log(this.a, somthing); return this.a + something;&#125;var obj = &#123; a: 2&#125;;var bar = function() &#123; return foo.apply(obj, arguments);&#125;var b = bar(3); // 2,3console.log(b); // 5 应用场景2： 创建复用的辅助函数123456789101112131415function foo(something) &#123; console.log(this.a, somthing); return this.a + something;&#125;function bind(fn, obj) &#123; return function() &#123; return fn.apply(obj, arguments); &#125;&#125;var obj = &#123;a: 2&#125;;var bar = bind(foo, obj);var b = bar(3); // 5 由于硬绑定的使用场景较多，因此ES5提供了Function.prototype.bind函数，它会返回一个硬绑定的新函数，将你指定的参数设置为this上下文，并调用原始函数。 bind()函数的功能之一就是可以把除了第一个参数之外的参数都传递给下层的函数，这种技术称为“部分应用”，是“柯里化”的一种。 4. new绑定在其他语言中，‘构造函数’是类中的特殊方法。使用new初始化时会调用类中的构造函数。但是js中的new机制其实和其他语言不同。 javascript中构造函数只是一些使用new操作符时被调用的函数。并不属于某个类，也不会实例化一个类。 使用new来调用函数，会执行： 1 创建一个全新对象 2 该对象会被执行[[prototype]]连接 3 新对象会绑定到函数调用时的this 4 如果函数中没有返回其他对象，new表达式中的函数调用会自动返回这个新对象eg:123456function foo(a) &#123; this.a = a;&#125;var bar = new foo(); // 1.创建bar需要的对象，2. prototype链接，3. this绑定到bar对象 4. 返回新的bar对象console.log(bar.a); 优先级默认绑定 &lt; 隐式绑定 &lt; 显式绑定/new绑定 判断this方法 函数是否在new中调用——this是创建的对象 函数是否通过apply,call调用——this绑定的是指定对象 是否是隐式绑定，obj.foo(), this指向最后一级调用; 是否是默认绑定——window(非严格)/undefined(严格) 特例有几个特例不太符合以上几种描述 1. 忽略this123456function foo() &#123; console.log(this.a);&#125;var a = 2;foo.call(null); // 输出2, null或undefined被传入call,apply或bind时会被忽略，变为默认引用。用途：bind柯里化foo.bind(null, 2)，apply展开参数 foo.apply(null, [2,3])。副作用：如果foo真的使用了this，会产生错误，综合而言，容易产生Bug。副作用解决——更安全的this:借助Object.create(null)产生的空对象, Object.create(null)与{}的不同是不会创建Object.prototype的委托:123456789function foo(a, b) &#123; console.log(\"a: \" + a + \",b: \" + b);&#125;var ø = Object.create(null);foo.apply(ø, [2, 3]);var bar = foo.bind(ø, 2);bar(3); // a: 2, b: 3 2. this词法ES6箭头函数无法使用以上规则，而是根据外层（函数或全局）作用域来决定this。12345678910111213141516function foo() &#123; return (a) =&gt; &#123; // this继承自foo console.log(this.a); &#125;&#125;var obj1 = &#123; a: 1&#125;var obj2 = &#123; a: 3&#125;var bar = foo.call(obj1); // 返回箭头函数bar.call(obj2); // 2 不是3 箭头函数的绑定无法被修改。 练习这是阮大大在issue下回怼别人的一个例子，感觉很有趣，就放在这里：123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(\"id:\", this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()();var t2 = f().call(&#123;id: 3&#125;)();var t3 = f()().call(&#123;id: 4&#125;); 使用箭头函数的定义的函数this取决于f定义阶段，第一个箭头函数的this继承于foo，foo的this被硬绑定到了{id: 1}。并且箭头函数没有本身的this，所以内部的箭头函数的this逐级向上继承全部来自于foo。答案：123id: 1id: 1id: 1 补充 为什么第一个例子this.count输出为NaN? 首先，这里是隐式绑定，this指向window，因此，RHS查询时，非严格模式下，产生了一个新的全局变量，值肯定是undefined，但是undefined + 1 = NaN，所以实际上foo中的this.count最终为NaN。 LHS与RHS为js引擎进行查询时的两种类型，L、R对应left,right，L为等号左侧，即被赋值对象查询，R为非等号左边，但不一定是赋值操作。函数传参具有隐式的LHS引用。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"复习作用域","date":"2017-09-04T01:48:21.000Z","path":"2017/09/04/【复习向】作用域/","text":"在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。 分词/词法分析例如var a = 2;,会被分解成为下面这些词法单元:var、a、=、2 、; 解析/语法分析(Parsing)这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”(Abstract Syntax Tree，AST)。 代码生成将 AST 转换为可执行代码的过程称被称为代码生成。 与其他语言不同，JavaScript 的编译过程不是发生在构建之前的。对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒(甚至更短)的时间内。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法(比如JIT，可以延迟编译甚至实施重编译)来保证性能最佳。 编译器/引擎/作用域了解作用域需要同时了解编译器和引擎的作用，编译器在编译时会进行作用域查询，之后生成引擎运行所需的代码。例如：变量的赋值操作会就执行两个动作，首先编译器会在当前作用域中声明一个变量(如果之前没有声明过，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。 引擎在运行时对变量的查找借助于作用域，查找分为两种类型，即：LHS查询和RHS查询。 RHS和LHS引用，分别代表非等号左侧（赋值操作的源头）和等号左侧（赋值操作的目标），其中‘=’操作和传入参数的操作都会导致关联作用域的赋值操作。 javascript引擎在代码执行前会进行编译，在这个过程中，例如var a = 2;这样的声明会被分解为两个独立的步骤： 首先，var a 在其作用域声明新变量，这会在最开始的阶段，即代码执行前。 接下来，a = 2会查询（LHS查询）变量a并对其赋值。 另外，不成功的RHS查询会抛出ReferenceError异常，不成功的LHS引用会导致自动隐式的创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常（严格模式下）。 以下例子：123456function foo(a) &#123; console.log(a+c); c = a;&#125;foo(2) 如上，引擎对于变量的查询分为LHS和RHS,c未使用var 或 let 等声明，在非严格模式下，进行LHS查询至顶层（全局作用域时），作用域会创建一个具有该名称的变量（undefined），返回给引擎，但在严格模式下，会报类似ReferenceError的异常。 如果对变量进行不合理的操作，例如对非函数类型的值进行函数调用，会报出TypeError(作用域判别成功，但对结果的操作不合法/不合理)。 词法作用域作用域分为词法作用域和动态作用域（perl,bash脚本），js中的作用域为词法作用域。 - 正常情况下，词法作用域是定义在词法阶段的作用域（写代码时代码中的变量和块级作用域写在哪里来决定的） - 但是也存在词法欺骗: eval是其中的一种,其实在setInterval()与setTimeout()的第一个参数可以为字符串，字符串的内容可以被解释为一段动态生成的代码。 - 另一种是with()，现在已经被禁止使用； eval词法欺骗：12345function foo(str, a) &#123; eval(str); // 执行后在内部创建了变量b console.log(a, b);&#125;foo('var b = 3;', 1) if、for中用var声明的变量并不包含于{}中，而是属于外部作用域。但是try/catch中的catch会自行创建一个块级作用域：1234567try &#123; undefined();&#125; catch(err) &#123; console.log(err);&#125;console.log(err); // ReferenceError——RHS查询错误（没有找到变量err） 此外，ES6的let会在if或者for中隐式的劫持以这种方式定义的变量的块状作用域。而且let包含死区，即不进行变量提升。 由作用域引申出闭包等相关： 无论通过何种手段将内部函数传递到词法作用域之外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。 实际上，定时器、事件监听、ajax请求或任何其他异步(同步)操作只要使用了回调函数就使用了闭包； 动态作用域与词法作用域的区别是，作用域链是基于调用栈的(this有点类似)，而不是作用域的嵌套；","tags":[]},{"title":"深入react技术细节","date":"2017-09-01T02:23:41.000Z","path":"2017/09/01/深入react技术细节/","text":"列出每点，待详细整理 getDefaultProps只执行一次：由于 getDefaultProps 是通过构造函数进行管理的，所以也是整个生命周期中最先开始执行的。而 mountComponent 只能望洋兴叹，无法调用到 getDefaultProps。这就解释了为何 getDefault- Props只执行一次。 mountComponent 本质上是通过递归渲染内容的，由于递归的特性，父组件的 componentWillMount 在其子组件的 componentWillMount 之前调用，而父组件的 componentDidMount 在其子组件的 componentDidMount 之后调用.updateComponent也是。 在 componentWillReceiveProps 、componentWillMount中调 用 setState，是不会触发 re-render 的，而是会进行 state 合并。 componentWillUnmount 中调用 setState，也是不会触发 re-render，因为所有更新 队列和更新状态都被重置为 null，并清除了公共类，完成了组件卸载操作 禁止在 shouldComponentUpdate 和 componentWillUpdate 中调用 setState，这会造成循环 调用，直至耗光浏览器内存后崩溃。 其实总共也就四个地方可以调用setState，componentWillMount、componentDidMount、componentWillReceiveProps、componentDidUpdate。其中在shouldComponentUpdate 和 componentWillUpdate不能调用的原因是4. setState 通过一个队列机制实现 state 更新。当调用 setState 时，实际上会执行 enqueueSetState 方法，并对 partialState 以及_pending-StateQueue 更新 列进行合并操作，最终通过 enqueueUpdate 执行 state 更新。 如果在 shouldComponentUpdate 或 componentWillUpdate 方法中调用 setState，此时 this._pendingStateQueue != null，则 performUpdateIfNecessary 方法就会调用 updateComponent 方法进行组件更新，但 updateComponent 方法又会调用 shouldComponentUpdate 和 componentWill- Update 方法，因此造成循环调用，使得浏览器内存满后崩溃。 tree diff由于diff算法中没有移动的概念，因此React跨层级移动会影响性能。节点被移动至其他节点时，会删除该节点及其子节点，在其他位置重新创建。 component diff:1. 如果是同一类型的组件，按照原策略继续比较 Virtual DOM 树即可；2. 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。3. 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切知道这点，那么就可以节省大量的 diff 运算时间。因此，React 许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff 算法分析。 element diff：1. insert插入 2. MOVE_EXISTING 旧的集合中有新组建类型 3. Remove删除。 React允许开发者对同一层级的同组子节点，添加唯一 key进行区分，为了防止单纯的顺序变化造成的删除更新。 diff算法从以上三个层面进行。 从左至右定义一个lastIndex初始值为0，每读取一个新队列中的值会进行变化。遍历新队列，看是否存在于旧队列，若存在，旧队列的位置与lastIndex做比较，如果满足moutIndex &lt; lastIndex则移动（lastIndex为max(lastIndex,moutIndex)），否则保持，若不存在则添加。最后遍历一遍旧队列，如果在新队列中不存在则进行删除。 React队列顺序改变导致更新性能最差的情况： 原队列N1、N2、N3….Nn长度为n，新队列 Nn、N1、N2、N3….N(n-1)，原本只是Nn移动，但是diff算法会进行n-1个节点的移动，是diff算法对于节点移动的优化是单向的。 React Patch：将 tree diff 计算出来的 DOM 异 列更新到真实的 DOM 节点上，最终让浏览器能够渲染出更新的数据","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"Reactjs","slug":"Reactjs","permalink":"http://yoursite.com/tags/Reactjs/"},{"name":"待完善","slug":"待完善","permalink":"http://yoursite.com/tags/待完善/"}]},{"title":"使用promise实现jsonp跨域请求及其优化","date":"2017-08-28T02:59:56.000Z","path":"2017/08/28/使用promise实现jsonp跨域请求及其优化/","text":"JSONP=JSON + padding，借助script标签的src属性，实现脚本跨域。 1. 前端实现需要注意的地方有很多点： 什么时候resolve，什么时候reject =&gt; 配合script的onload，onerror事件； 利用闭包，自定义的临时回调函数负责将取回的数据放到闭包所能获取的变量中从而实现resolve，且回调函数需要进行清除； 自定义的script需要进行清除或复用； 12345678910111213141516171819202122232425262728293031323334353637383940const url = 'http://localhost:10011'; // URL of the external scriptfunction loadData(url) &#123; let _data; const script = document.createElement('script'); script.src = url + '?jsoncallback=doSomething'; window.doSomething = function(data) &#123; _data = data; &#125; document.body.appendChild(script); return new Promise((resolve, reject) =&gt; &#123; if(script.readyState)&#123; // IE支持 onreadystatechange 事件，而标准浏览器支持 onload 事件来判断脚本的执行状态。 script.onreadystatechange = function() &#123; if(this.readyState == 'completed' || this.readyState == 'loaded')&#123; resolve(_data); delete window.doSomething; &#125; &#125; &#125; else &#123; script.onload = function() &#123; resolve(_data); delete window.doSomething; &#125; &#125; script.onerror = function() &#123; reject(new Error('could not load this script')); delete window.doSomething; &#125; &#125;);&#125;loadData(url).then((data)=&gt; &#123; console.log(data);&#125;); 我们通过loadData函数返回一个Promise，当script标签onload成功时进行resolve，并传回callback获取到的请求数据。 2. 后端实现在Server端：JSONP跨域请求，服务器要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。服务器端代码如下，在下面的代码中，如果前端请求包含约定的callback参数，后端获取方法名后，用该方法包住JSON数据，传递给前端。若不包含约定的callback参数,则直接返回原数据。1234567891011121314151617181920const http = require('http');const urllib = require('url');const port = 10011;const data = &#123; name: 'iwtofly'&#125;;http.createServer(function(req, res) &#123; const params = urllib.parse(req.url, true); console.log(params); if (params.query &amp;&amp; params.query.jsoncallback) &#123; const str = params.query.jsoncallback + '(' + JSON.stringify(data) + ')'; res.end(str); &#125; else &#123; res.end(JSON.stringify(data)); &#125;&#125;).listen(port, function() &#123; console.log('server is listening on port ' + port);&#125;) 上面的实践中规定了’jsoncallback’参数用于传递回调函数名称。当采用JSONP方式调用时，返回回调函数的调用。 3. 优化可以看出，在上面的实现中，没有进行script标签的删除，因为一旦你的应用程序中使用到了轮询，这样只增加节点而不删除，将导致内存不断增长，增长的比例和加载脚本执行的内容也有很大的关系，所以十分有必要在脚本执行完成以后删除这些script节点。 我们很自然会想到使用removeChild进行节点的删除。如下：123456789101112...const script = document.createElement('script');script.src = url + '?jsoncallback=doSomething';window.doSomething = function(data) &#123; _data = data;&#125;var body = document.body;body.appendChild(script);...// 在Promise中，而不是append之后，不然脚本还没有加载就会被删除。body.removeChild(script); 经人测试后发现这样的解决方案不能完全避免内存的不断增长，标准浏览器包括Chrome随着轮询的都会有内存增长的现象，不过增长程度微乎其微（轮询间隔2m，增长速度也只有4k-8k）。但是IE会有十几到几十K的内存增长。 解决办法：创建一个空的标签，用于垃圾回收，将要清除的元素append至garbageBin，再利用innerHTML=’’进行清空。123456789101112function discardElement(element) &#123; var garbageBin = document.getElementById('IELeakGarbageBin'); if (!garbageBin) &#123; garbageBin = document.createElement('div'); garbageBin.id = 'IELeakGarbageBin'; garbageBin.style.display = 'none'; document.body.appendChild(garbageBin); &#125; // move the element to the garbage bin garbageBin.appendChild(element); garbageBin.innerHTML = ''; &#125; 参考javascript removeChild 导致的内存泄漏script标签清除garbageBin jquery getJSON内部实现贴 题外话众所周知，jsonp用于发送get请求，那么假如非要用jsonp发送post请求该如何实现呢？","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"待完善","slug":"待完善","permalink":"http://yoursite.com/tags/待完善/"}]},{"title":"也谈MV*","date":"2017-08-23T03:00:25.000Z","path":"2017/08/23/也谈MV*/","text":"复杂的软件开发需要有合理的开发架构，从另一方面来说，这也是开发规范的一种。 MVC、MVP、MVVM源自于职能分化和规划的思想与目的…无论是哪种架构，其实都离不开view、model，区别在于控制流是怎么样的以及各部分之间的分工。 1. 从MVC说起MVC(Model–view–controller)是架构设计模式中的一种，它强制将业务数据与用户界面隔离，用控制器来管理逻辑和用户输入。 模型model: 保存数据，和后端交互同步应用数据或者校验数据视图view: 用户界面，是model的可视化表示，代表当前状态的视图。控制器controller: 业务逻辑，连通model与view, model的任何改变会应用到View中，view的操作会通过Controller应用到Model。 图1 controller接收指令从接收用户指令的角度讲MVC分为两种，view接收指令与controller接收指令（图1），实现上也可能两者并存。 图2 controller与view同时接收用户指令如图2为两者并存，hashChange相关事件直接由controller接收，用户点击等操作由view层接收。这种模式更为灵活，但是又不算有真正的controller，换句话说’fat views and thin controllers’。目前，采用这种模式的有backbone。backbone是一个小巧灵活的库，是个不错的工具，适合那些有一定Web基础，喜欢原生JS，自己去操作DOM（因为它没有DOM Binding），写一些框架、库、插件的童鞋。它的特点是灵活，并不全包。只是帮你实现一个MVC模式的框架，更多的还需要自己去实现。MVC缺点：model对外暴露了set和on方法，导致view层可以随意改变或监听Model中值的变化，随着项目越来越复杂，数据流动方式会越来越乱，某个庞大的Model中某个字段改变之后有可能触发无数个change事件，导致一连串的change被触发。2. 传说中的MVP-fat models and thin controllers 图3 MVP模式在MVP模式下，view与presenter，presenter与model之间均为双向通信。presenter将model于view完全隔离开来。具有如下特点：&gt; Passive View（被动视图）&gt; Supervising Controller3. MVVM 图4 MVP模式 MVVM assumes that changes in the ViewModel will be reflected in the view by a robust data-binding engine。MVVM基本上与 MVP 模式完全一致，但是它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel上，Angular为典型代表。 4. 再来看Redux当你感觉自己熟练掌握react的state、props、各类生命周期的时候，再来看看redux，会觉得之前仿佛只会写onclick。看一下redux的三大原则： 1.单一数据源：一个应用永远只能有唯一数据源，而不是像传统MVC中那样有多个Model、Model间可以相互监听。2.状态是只读的：reducer的作用是根据当前的action对state进行迭代，并不是直接修改；3.状态修改由纯函数来完成：reducer为纯函数，输入确定-输出确定 redux的关键模块有：Reducer、Store、Actions（action creator+action）、Components,其实可以将Redux+react看做MVC的一种实现方式，只不过它强制要求了单向数据流。 图5 Redux与MVC Actions = Controller：在应用中用户触发某些行为时，我们需要dispatch一个action，进行相应的异步请求或业务逻辑处理；Reducer = Model：Reducer决定了当一个action触发时，是否要进行相应的数据更新Store = ???： Store在MVC中并没有严格的对应关系，它可以比作连接各个Reducer的模块；Components = Views： 进行渲染 Thanks to：1.Scaling Isomorphic Javascript Code2.谈谈MVC模式——阮一峰3.Thinking in Redux (when all you’ve known is MVC)","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/框架/"}]},{"title":"js中的类型判定","date":"2017-08-22T01:40:47.000Z","path":"2017/08/22/js中的类型判定/","text":"深拷贝或者日常开发中经常涉及到一些关于类型判定的场景，尤其是数组，我在这一小节，着重分析数组、null、NaN的判断方法。js有5种基本类型，分别为number、string、boolean、null、undefined。引用类型Object，数组属于引用类型中的一种。typeof 而方法返回的是字符串，有六种可能：”number”、”string”、”boolean”、”object”、”function”、”undefined”。1234567891011function Foo() &#123; &#125;typeof 123 // numbertypeof '123' // stringtypeof undifined // undefinedtypeof true // booleantypeof null // objecttypeof [] // objecttypeof Foo // function Array类型判断数组类型的判断大致有三种： 1. constructor/instanceof12value instanceof Arrayvalue.constructor instanceof的其中一个问题在于，它假定只有一个全局环境。如果网页中包含不同的框架，则存在多个全局执行环境，从而有多个Array构造函数。 2. isArray()ECMAscript5提出了isArray，它可以解决instanceof存在的多环境问题，但是兼容性有限（IE9+）。 3. Object的toString方法Object中的toString方法是最受青睐的一种，可以用来进行各种类型的判定。1234function getType(arg) &#123; let typeStr = Object.prototype.toString.call(arg); return typeStr.replace(/\\[object|\\]|\\s/g, '');&#125;, 当然，没有万全的保障，这个也是有一定问题的。要保证你的环境下，Object.prototype.toString方法没有被重写。 NaN判断首先判断NaN之前，我们要知道它是个什么类型的，not a number但是它是——number类型。 1.isNaN()ECMAScript 2015/ES6 中定义了Number.isNaN()。isNaN()会首先尝试将这个参数转换为数值，然后才会对转换后的结果是否是NaN进行判断。因此，对于能被强制转换为有效的非NaN数值来说（ 值得一提的是，空字符串和布尔值会被强制转换为数值0或1），返回false值也许会让人感觉莫名其妙。比如说，空字符串就明显”不是数值“（not a number）。1234567891011// isNaN可以看做isNaN = function(value) &#123; Number.isNaN(Number(value));&#125;isNaN(NaN); // trueisNaN(undefined); // trueisNaN(&#123;&#125;); // trueisNaN(true); // falseisNaN(null); // falseisNaN(37); // false 2. x!==xNaN有个特点，和任何对比均不相等，就是我连自己都不认的这种特点，我们才能认出它。123isNaN = function (x) &#123; return x !== x;&#125; null判断利用!null = true，typeof null = ‘object’，null != 0;123isNull = function () &#123; return (!x &amp;&amp; typeof(x)!=\"undefined\" &amp;&amp; x!=0);&#125;","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"简单问题反省","slug":"简单问题反省","permalink":"http://yoursite.com/tags/简单问题反省/"}]},{"title":"js中的深度拷贝","date":"2017-08-16T13:38:44.000Z","path":"2017/08/16/js中的深度拷贝/","text":"背景： javascript中，由于Object和Array这类引用类型的值存在，复制变量时若只是简单赋值，两个变量指向同一个堆变量，此时的赋值只是地址赋值。改变其中的一个对象，另外一个也会随之改变。因此，在开发时会有用到深拷贝的场景，例如react进行setState时。 浅拷贝浅拷贝如前文所说，拷贝原对象的实例，但是对其内部的引用类型值，拷贝的是其引用。1234567891011121314151617var obj1 = &#123;b:2&#125;;var obj2 = obj1; // 此时只拷贝了对象的地址console.log(o1===o2); // trueobj1.b = 3;console.log(obj1); // 输出&#123;b:3&#125;console.log(obj2); // 同样输出&#123;b:3&#125;var arr1 = [1,2,3];var arr2 = arr1;arr1 === arr2; // truearr2.push(4);console.log(arr2); // [1,2,3,4]console.log(arr1); // [1,2,3,4] jquery中$.extend({}, obj)，Array.prototype.slice()和Array.prototype.concat()返回对象或者数组的浅拷贝。example: 123456789var arr1 = ['iwtofly', &#123;age: 22&#125;];var arr2 = arr1.slice();console.log(o1 === o2); // falseconsole.log(o1[1] === o2[1]) // truearr2[1].age = 23;console.log(arr2[1].age); // 23console.log(arr1[1].age); // 23 浅拷贝实现方法之一， 下段实现中的shallowClone：123456789101112131415161718192021222324252627282930313233module.exports = &#123; /** * 获取类型 * @param &#123;object/array/undefined/null/number/string/...&#125; arg 待判断类型参数 * @return &#123;String&#125; 参数类型（首字母大写） */ getType: function(arg) &#123; let typeStr = Object.prototype.toString.call(arg); return typeStr.replace(/\\[object|\\]|\\s/g, ''); &#125;, /** * 浅拷贝--非递归 * @param &#123;[type]&#125; src 待拷贝的对象 * @return &#123;[type]&#125; 拷贝结果 */ shallowClone: function(src) &#123; if (!src &amp;&amp; typeof src !== 'object') &#123; console.log('it is not a object'); &#125; const type = this.getType(src); let target = type === 'Array' ? [] : &#123;&#125;; for (let key in src) &#123; if (src.hasOwnProperty(key)) &#123; target[key] = src[key]; &#125; &#125; return target; &#125;, ···&#125; 深拷贝最简单的深拷贝是利用序列化和反序列化：1var target = JSON.parse(JSON.stringify(obj)); 但是这种方法在序列化JavaScript对象时，所有函数和原型成员会被有意忽略，拷贝结果会丢失function、Date等类型。除此之外，按照上面浅拷贝实现的思路只需要进行递归即可实现深拷贝如下：12345678910111213141516171819202122232425262728293031323334353637383940module.exports = &#123; /** * 获取类型 * @param &#123;object/array/undefined/null/number/string/...&#125; arg 待判断类型参数 * @return &#123;String&#125; 参数类型（首字母大写） */ getType: function(arg) &#123; let typeStr = Object.prototype.toString.call(arg); return typeStr.replace(/\\[object|\\]|\\s/g, ''); &#125;, ··· /** * 深拷贝--递归 * @param &#123;[type]&#125; src 待拷贝的对象 * @return &#123;[type]&#125; 拷贝结果 */ deepClone: function(src) &#123; if (!src &amp;&amp; typeof src !== 'object') &#123; console.log('it is not a object'); &#125; const type = this.getType(src); let target = type === 'Array' ? [] : &#123;&#125;; for (let key in src) &#123; if (src.hasOwnProperty(key)) &#123; const subType = this.getType(src[key]); if (subType === 'Object' || subType === 'Array') &#123; // Object sub target[key] = this.deepClone(src[key]); &#125; else &#123; target[key] = src[key]; &#125; &#125; &#125; return target; &#125;&#125; 结果测试1234567891011121314let Clone = require('../clone.js');let o1 = ['iwtofly', &#123;age: 23&#125;, [1,2,3]];let shallow = Clone.shallowClone(o1);let deep = Clone.deepClone(o1);console.log(shallow);console.log(deep);console.log('shallow is equal to o1? ',shallow === o1);console.log('deep is equal to o1? ', deep === o1);console.log('shallow[1] is equal to o1[1]? ',shallow[1] === o1[1]);console.log('deep[1] is equal to o1[1]? ', deep[1] === o1[1]); 文件执行结果：123456[ 'iwtofly', &#123; age: 23 &#125;, [ 1, 2, 3 ] ][ 'iwtofly', &#123; age: 23 &#125;, [ 1, 2, 3 ] ]shallow is equal to o1? falsedeep is equal to o1? falseshallow[1] is equal to o1[1]? truedeep[1] is equal to o1[1]? false 注意 有时突然想到深拷贝第一反应只会想到要区分Object类型，却忘记Array类型也要在初始化target时进行区分 区分数组和其他类型有多种方法，我常用的是下面的第一个方法 Object的toString方法（Object.prototype.toString.call(obj)），再用正则去匹配，滤掉相同/公共的部分； object.constructor === Array, 数组的构造函数均为[Function: Array]，但是多个环境，例如iframe嵌入的页面进行交互时无法使用，因为两个环境下存在不同的构造函数。 for in会遍历出prototype中的属性 如果要求高的话，其实还需要单独判断Date、RegExp…类型——new Date(src.getDate())，new RegExp(src.valueOf())。 object.keys(),不会遍历原型链上的属性。 js类型判定专栏; 其他方法深拷贝详见：https://github.com/iwtofly/FE-tools/blob/master/jsUtil.js本方法实现：https://github.com/iwtofly/FE-tools/blob/master/clone.js","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"简单问题反省","slug":"简单问题反省","permalink":"http://yoursite.com/tags/简单问题反省/"}]},{"title":"日常CSS备忘","date":"2017-08-16T11:38:25.000Z","path":"2017/08/16/常忘CSS梳理备份/","text":"由于经常使用框架配套组件库，CSS技巧会生疏，今天转正面试被问到transiton都感觉很尴尬，因此在此梳理记录。 1. 内容超过一定宽度时设置…1234567&#123; width: 27em; white-space: nowrap; text-overflow: ellipsis; -o-text-overflow: ellipsis; overflow: hidden;&#125; 内容超出所设置宽度时会出现’…’。white-space: nowrap会使文字保持在一行，overflow: hidden;超过设置的宽度则不显示。 2. CSS3的transition过渡属性有人说transition、transform、animation分别对应于过渡、变换、动画。 transition的作用是平滑的改变CSS的值，transition有以下几个属性： transition-property:指定过渡的性质，比如transition-property:backgrond transition-duration:过渡持续时间 transition-delay: 延迟过渡时延 transition-timing-function: 指定过渡类型,ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier example:12345678910111213.mydiv&#123; width: 100px; height: 100px; background: blue; transition: all 2s 0.5s ease; -webkit-transition: all 2s 0.5s ease; -moz-transition: all 2s 0.5s ease; -o-transition: all 2s 0.5s ease;&#125;.mydiv:hover&#123; width: 300px; background: pink;&#125; all为width和background均参与变换，最终效果为，鼠标hover之后延迟0.5s颜色渐变、宽度渐变。参与transition的属性有非常多，除了以上两种还有margin、color、border等等，还有transform相关。 参考：https://www.w3.org/TR/css3-transitions/#animatable-properties- 3. CSS3-transform 变换transform用于调整scale、rotate、translate等等。例如在垂直水平居中时常用1transform: translate(-50%, -50%); 此外transform经常和transition一起应用，营造比较丰富的动画。transform作用于block元素！！example:123456789101112131415161718.trans-div &#123; display: block; line-height: 100px; width: 100px; background: #beceeb; margin:30px auto; text-align:center; -webkit-transition:all 2s ease-in-out; -moz-transition:all 2s ease-in-out; -o-transition:all 2s ease-in-out; transition:all 2s ease-in-out;&#125;.trans-div:hover &#123; -webkit-transform:rotate(720deg) scale(2,2); -moz-transform:rotate(720deg) scale(2,2); -o-transform:rotate(720deg) scale(2,2); transform:rotate(720deg) scale(2,2);&#125; 1&lt;a class=\"trans-div\"&gt;hover me&lt;/a&gt; 效果：由内向外旋转同时放大。 4. CSS3-animation 动画animation需要配合keyframes使用，定义动画的关键帧。之后用animation规定使用动画的 frame名称、持续时间、ease等效果。12345678910111213141516171819div &#123; width:100px; height:100px; background:red; position:relative; animation:mymove 5s infinite; -webkit-animation:mymove 5s infinite; /*Safari and Chrome*/&#125;@keyframes mymove&#123; from &#123;left:0px;&#125; to &#123;left:200px;&#125;&#125;@-webkit-keyframes mymove /*Safari and Chrome*/&#123; from &#123;left:0px;&#125; to &#123;left:200px;&#125;&#125; 也可以分开定义animation的各个属性，分别为： animation-name 名称animation-duration 持续时间animation-timing-function 动画的速度曲线animation-delay 延时animation-iteration-count 应该播放的次数（infinite是无限循环）animation-direction 动画方向 参考：http://lin-xi.github.io/css3-animation 5. 关于单位vh、vw、vm与calc vw：是相对于视窗的宽度，100vw为整个宽度vh：是相对于视窗高度，100vh为整个视窗高度vm：取决于视窗高宽小的一方 vw、vh分别对应于浏览器的window.innerWidth/window.innerHeight这一项； calc不能计算诸如 calc(100vh-20px)的公式是个错误的说法！！！calc的优势就在于可以计算mixing units；一直以来以为calc不能计算vh-px，结果发现是’-‘运算符两边没有空格导致不生效。心累。 参考：https://www.smashingmagazine.com/2015/12/getting-started-css-calc-techniques/ 6. 对:after或者:before伪元素设置image大小相关知识点：background-image相关项目中小需求是:**切换导航时tab前出现定位icon，使用:before，关键点如下： 123456789101112.tab:before &#123; content: ''; display: inline-block; font-size: 0; background-image: url('urlbalabal'); background-repeat: no-repeat; background-size: contain; // 此处选择了contain margin-right: 3px; margin-bottom: -4px; height: 18px; width: 12px;&#125; content本身可以设置url(‘imgurl’)，但是这样无法设置图片大小。因此要采用background-image。12345background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | containbackgroud-size:contain; //把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。backgroud-size:cover; // 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。// 背景图像的某些部分也许无法显示在背景定位区域中。 容器与背景图长度比:150/100=1.5宽度比:60/50=1.2cover 取大,所以就按照 长度比 1.5 (等比缩放背景图片)contain 取小,所以就按宽度比 1.2 (等比缩放背景图片) 参考： https://stackoverflow.com/questions/8977957/can-i-change-the-height-of-an-image-in-css-before-after-pseudo-elements http://yijiebuyi.com/blog/260c099f3462623f6c1e4425e3bd8664.html 7. position:有几种定位方式，分别相对谁定位8. float和inline-block达成的横排效果上有什么区别？如何消除？","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"简单问题反省","slug":"简单问题反省","permalink":"http://yoursite.com/tags/简单问题反省/"}]},{"title":"ES6 class继承与ES5继承","date":"2017-08-13T07:07:35.000Z","path":"2017/08/13/ES6-class继承与ES5继承/","text":"JS中的继承是一个比较麻烦的问题，最近在看js设计模式，前几章涉及到许多继承相关的知识点，例如prototype、constructor、__proto__、构造函数，实例和原型。因此在此进行思考和梳理。 es5 es6继承ES6 CLASS","tags":[]},{"title":"Promise实现原理","date":"2017-08-02T13:49:08.000Z","path":"2017/08/02/Promise实现原理/","text":"","tags":[]},{"title":"lazyLoad实现","date":"2017-03-20T14:31:31.000Z","path":"2017/03/20/lazyLoad实现/","text":"lazyLoad（懒加载），是对网页进行优化的一种方案，可以适当提升用户体验，它的作用： 网站性能优化，提高用户体验 页面如果有很多图片的时候，当你滚动到相应的行时，当前行的图片才即时加载的，这样子的话页面在打开只加可视区域的图片，而其它隐藏的图片则不加载。 简易DEMO链接（图片请求自Flicker）：http://iwtofly.cn/demos/lazyLoad/index.html lazyload的难点在如何在适当的时候加载用户需要的资源(这里用户需要的资源指该资源呈现在浏览器可视区域)。因此我们需要知道几点信息来确定目标是否已呈现在客户区,其中包括： 可视区域相对于浏览器顶端位置； 待加载资源相对于浏览器顶端位置； 未完待续…","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"React中createClass、PureComponent、Component的不同","date":"2017-03-07T09:36:02.000Z","path":"2017/03/07/React中createClass、pureComponent、Component的不同/","text":"16年6月开始使用React，至今写法上发生了很大的变化，不过也可能是一开始接触的太low了。我使用过的创建react组件的方式大致有三种形式。 var Name = React.createClass class Name extends Component class Name extends PureComponent 友情提示：后两种需要babel转码 那么，前两种方式有哪些区别呢？首先，从createClass到class extends的改变是基于ES6的语法糖——class, 很类似于php等语言中的语法。本质上来讲，他们之间的差别不大，但是掌握他们的不同可以让我们更好的选择适合的方案。我们简单来看一下两种方法下构成的代码： createClass方式123456789101112131415161718192021222324252627282930313233import React, &#123;PureComponent&#125; from 'react';const Example = React.createClass(&#123; propTypes: &#123; title: React.PropTypes.string.isRequired &#125;, mixins: [SomeMixin], // ES6不支持 getDefaultProps() &#123; return &#123; title: 'I am title' &#125;; &#125;, getInitialState() &#123; return &#123; name: 'world' &#125; &#125;, handleClick() &#123; console.log('clicked!'); &#125;, render() &#123; return( &lt;div&gt; &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt; hello, &#123;this.state.name&#125; &lt;/div&gt; ) &#125;&#125;);export default Example; class extends方式123456789101112131415161718192021222324252627282930313233343536373839import React from 'react';class Example extends React.Component &#123; constructor(props) &#123; super(props); // super之后才能使用this this.state = &#123; name: 'world' &#125; // 重要！！ this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; console.log('clicked!'); &#125; render() &#123; const &#123;name&#125; = this.state; return( &lt;div&gt; &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt; hello, &#123;name&#125; &lt;/div&gt; ) &#125;&#125;;// 验证类型 =&gt; 对应 propTypes: &#123;&#125;Example.propsTypes = &#123; title: React.PropTypes.string.isRequired,&#125;// 设置默认属性值 =&gt; 对应 getDefaultProps() &#123;&#125;Example.defaultProps = &#123; title: 'I am title'&#125;;export default Example; 1. 语法区别敲黑板， 注意逗号 ，切忌自嗨。class extends的语法形式引入了 constructor ,方便我们调用 super() 函数来为Component传递属性。还可以传递context上下文，实现依赖注入， 这部分，下次再写 。 2. state初始化在createClass中，我们创建了一个getInitialState返回创建的state对象。在class extends方式中，我们在constructor中调用了super()之后，访问this，创建this.state，初始化声明状态。 3. this的区别（重要）createClass时，React会自动帮助我们处理 this 指向。但是，在class extends的方式中，对button进行事件绑定时，需要注意，此时this默认并没有绑定到React实例上，因此需要做相应的处理：1&lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;/button&gt; 或者如上例所示，在constructor中中调用了super()之后，改变this.handleClick执行的上下文。 那么PureComponent与直接使用Component又有什么不同呢？ PureComponent与Component的不同点在没有使用Redux的情况下，我们需要进行优化减少不必要的render时，经常需要手写shouldComponentUpdate，复杂的情况下要进行一系列深比较等。当然，也可以配合Immutable.js实现。而PureComponent的方式创建组件时，react会帮助我们进行一次 ‘浅比较’’ ，一定程度上来减少不必要的render。这里，我给浅比较加上了一个引号。 我的测试代码如下，father.js为父组件，sub.js为子组件 father.js12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123;PureComponent, Component&#125; from 'react';import Sub from './sub.js';// export default class Father extends PureComponent &#123;export default class Father extends Component &#123; constructor(props, context) &#123; super(props, context); this.state = &#123; items: [], test: undefined &#125; &#125; componentDidMount() &#123; console.log(\"father componentDidMount\"); &#125; handleClick() &#123; this.setState(&#123;items: this.state.items.concat(['new-item'])&#125;); // this.setState(prevState =&gt; (&#123; // items: prevState.items.concat(['new-item']) // &#125;)) &#125; handleClickFather() &#123; this.setState(&#123; test: '123' &#125;) &#125; render() &#123; console.log('Father --render'); return( &lt;div&gt; It is the father! &lt;button onClick=&#123;this.handleClickFather.bind(this)&#125;&gt;father Button&lt;/button&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;sub Button&lt;/button&gt; &lt;Sub items=&#123;this.state.items&#125;/&gt; &lt;/div&gt; ) &#125;&#125; sub.js1234567891011121314151617181920212223242526import React, &#123;PureComponent, Component&#125; from 'react';// export default class Sub extends PureComponent &#123;export default class Sub extends Component &#123; constructor(props, context) &#123; super(props, context); console.log('context in constructor',context); this.state = &#123; title: this.context.title &#125; &#125; componentDidMount()&#123; console.log(\"sub componentDidMount\"); &#125; render() &#123; console.log('sub --render'); return( &lt;div&gt;it is my sub, the title get from apptestpage is ---- &#123;this.state.title&#125;&lt;/div&gt; ) &#125;&#125;Sub.contextTypes = &#123; title: React.PropTypes.string&#125; 可以看出，father.js调用了sub.js,我们在father.js中设定了两个button，第一个’father button’绑定事件将会更改father组件中的state——test，这个test并未作为参数传入sub。另一个button，sub button绑定的事件将会改变items,并且sub组件接收该props。father.js与sub.js均使用 class Sub extends Component 时，点击两个按钮，发现控制台均打印：12Father --rendersub --render 也就是说，test的改变，引起了sub不必要的一次render。 之后，再使用 class Sub extends ComponentPure 创建组件，点击father button，控制台打印：1Father --render 点击sub button,控制台打印12Father --rendersub --render 此时，才是我们想要的结果。 但是 ，使用PureComponent，需要注意的是，我此时使用的方法是数组的concat，concat有一个特点是会新创建一个数组对象，假如使用push方法，就会出现sub.js不进行render的情况。也就是说，PureComponent比较的是简单类型的值，或者对象的地址，这些内容都有一个特点，应该是存在栈当中的（恩，才疏学浅，我是这么骗自己的。如果错了，不要当真）。因此，在大多数情况下，我们还是需要手写shouldComponentUpdate滴。恩，当然，还可以移步redux。 好了，不喜欢写文档的我，写到这里我已经用尽洪荒之力了。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"Reactjs","slug":"Reactjs","permalink":"http://yoursite.com/tags/Reactjs/"}]},{"title":"JS数组去重","date":"2017-02-25T08:44:54.000Z","path":"2017/02/25/JS数组去重/","text":"注意 ：需要注意包含NaN类型数据的去重 使用Array.prototype.indexOf(), indexOf使用的是严格等 ‘===’ 思路1 =&gt; arr.filter()12345function unique(arr) &#123; return arr.filter(function(item, index) &#123; return arr.indexOf(item) === index; &#125;)&#125; 思路2 =&gt; arr.forEach()123456789function unique(arr) &#123; var ret = []; arr.forEach(function(item) &#123; if (ret.indexOf(item) === -1) &#123; ret.push(item); &#125; &#125;); return ret;&#125; 思路3 =&gt; es2015新增方法includes 解决NaN123456789function unique(arr) &#123; var ret = []; arr.forEach(function(item) &#123; if (!ret.includes(item)) &#123; ret.push(item); &#125; &#125;); return ret;&#125; 思路4 =&gt; 借助set，map等ES6新增类型https://www.toobug.net/article/array_unique_in_javascript.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"小白眼中的跨域","date":"2017-02-15T13:02:20.000Z","path":"2017/02/15/小白眼中的跨域/","text":"跨域，这个纠结好久的问题，最近终于有些思路了。仿佛预见了自己将要不是哪个懒得只知道用cors中间件的小白啦！ 什么是跨域我们来看一下什么是跨域以及同源策略： 通过XHR实现Ajax通信的的主要限制，来源于跨域安全策略。所谓同源是指，域名，协议，端口相同。默认情况下，XHR对象只能访问与包含它的页面位于同一个域的资源。这种安全策略可以预防某些恶意行为。简单来说，形如a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。 跨域的几种情况下表所示： URL1 URL2 说明 通信否 http://www.a.com/a.js http://www.a.com/b.js 同一域名下 可 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名不同文件夹 可 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名不同端口 否 http://www.a.com/a.js https://www.a.com/b.js 同一域名不同协议 否 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 否 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 否 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 否（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 否 其中，如果是协议和端口造成的跨域问题前端是无能为力的；而且，在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。 如何解决跨域问题跨域问题的解决办法有很多种,大致可以分为两类： 一类是Hack，比如通过title、navigation、script等对象传递信息， JSONP 就是一种Hack方式; 另一类是HTML5支持，其中一种是 Access-Control-Allow-Origin 响应头，一个是 window.postMessage ; 1. JSONP 实现原理：虽然我们不能直接请求异源上的资源，但是在js中如img，script标签却是可以得到其他服务器上的资源的，那么我们就可以通过这样的方式将一段js代码间接地从外部引入。通过script标签向目标源发起一个GET请求，服务器根据请求的参数返回包含js的代码。 JSONP是JSON with Padding的简写，是一个非官方协议，她允许在服务端集成Script Tags返回客户端，通过javascript callback的形式实现跨域访问（注：简单实现形式是这样）。 缺点：JSONP只能实现GET请求。随着现在RESTful的兴起，JSONP显得力不从心了。因为，RESTful不仅有GET，还存在POST、PUT、PATCH、DELETE等等。 下面为index.html的代码：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jsonp test&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; var url = 'ticker.js'; function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute('src', src); document.body.appendChild(script); &#125; function callBack(data) &#123; console.log(data); &#125; window.onload = function() &#123; addScriptTag(url+'?callback=callBack'); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其中，ticker.js中的内容如下：123456callBack( &#123; name:'iwtofly', job: 'FE' &#125;) 结果显示如下： 此外还有很多好玩的地方可以小探索一下，例如google、Flickr等等都提供了JSONP的回调接口，笔者不才最近正在小玩了下Flickr，等稍有成果之后再做呈现。 2. iframe + domain原理 —— 形如http://a.com/video 与 http://b.a.com/video、http://c.a.com/video 这种 主域相同，子域不同的情况，可以通过设置document.domain让它们同域。限制 —— 同域document提供的是页面间的相互操作，需要载入iframe页面(即，只能通过页面嵌套的方式) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.domain用来得到当前网页的域名，给document.domain属性赋值是有限制的 —— 只能赋成当前的域名或者基础域名。http://b.a.com/ 为当前域名，http://a.com/ 为基础域名。因此，利用document.domain实现跨域前提条件为，这两个域名必须属于同一个基础域名而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。12345678910// 当前为http://iwtofly.cn/videovar ifr = document.createElement('iframe');ifr.src = 'http://www.iwtofly.cn/video'; ifr.onload = function()&#123; var ifrdoc = ifr.contentDocument || ifr.contentWindow.document; ifrdoc.getElementsById(\"foo\").innerHTML);&#125;;ifr.style.display = 'none';document.body.appendChild(ifr); 假设上述代码所在的URL为http://iwtofly.cn/video ，它对http://www.iwtofly.cn/video 的DOM访问要求后者将document.domain往上设置一级:1document.domain = iwtofly.cn; document.domain 只能从子域设置到主域，往下设置以及往其他域名设置都是不允许的 3. cors CORS（Cross Origin Resource Sharing, 跨源资源共享）是W3C的一个工作草案，定义了在必须访问跨源资源时浏览器与服务器应该如何进行沟通。其背后的思想，就是定义HTTP头部让浏览器与服务器进行沟通，从而决定请求或相应的成功与否，以便服务器根据这个头部信息来决定是否给予相应。 Origin头部示例：1Origin: http://iwtofly.cn 如果服务器认为这个来源的请求是可以接受的，就在Access-Control-Allow-Origin头部中回发相同的源信息，’*’代表允许一切来源的请求，一般设置为公共资源。示例：1Access-Control-Allow-Origin: http://iwtofly.cn 笔者用过这方面的工具有nodejs cors中间件。cors中间件在使用前需要安装cors模块：1$ npm install cors --save 然后，在 index.js 内添加中间件 app.use(cors());1234567891011121314151617181920var express = require('express');var app = express();var cors =require('cors');app.use(cors()); // 作用于全局的请求app.get('/table',function (req, res) &#123; res.send(data);&#125;)// 只用于'/table'的GET的写法// app.get('/table', cors(), function (req, res) &#123;// res.send(data);// &#125;);var server = app.listen(8988, function () &#123; var host = server.address().address; var port = server.address().port; console.log('back server: http://%s:%s', host, port);&#125;) 只有使用 cors()中间件才会释放出我们 Api 的访问权限。最好是控制哪些客户端可以进行连接，哪些方法可以使用。最主要的是，必须要在请求的时候加入到头部。在我们这个例子中仅需要设置三个属性： orgin（访问域）、method（访问方法）、alloweHeaders（请求头）。12345678910111213141516171819var express = require('express'); var cors = require('cors'); var app = express();app.use(cors(&#123; origin: ['http://localhost:3001'], methods: ['GET', 'POST'], alloweHeaders: ['Conten-Type', 'Authorization']&#125;));app.get('/', function(req, res) &#123; res.json(&#123;status: 'My Api is alive!'&#125;);&#125;);app.listen(3000, function() &#123; console.log('My Api is running...');&#125;);module.exports = app; 4. 中间层代理跨域问题的核心是不同源访问，因此，如果我们转换为同源请求，就不存在这个问题啦。通过搭建中间层，可以是java，也可以是node.js，通过将服务端的请求进行转发，换句话说，就是dispatcher了一层，那么前端请求的地址，就被转发了，所以很好的解决跨域问题。缺点：如果对性能有考量的产品，就需要慎重选择这个方案，因为多了一层中间转发，不管是网络开销，还是性能负载都是有一定的影响。 做了一个小测试，假设以下为server2.js,我们真正要请求的后端，运行在3002端口：1234567891011121314/** * 中间层跨域中的：server后端 */var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.json(&#123; name: 'iwtofly', job: 'FE' &#125;)&#125;);app.listen(3002);console.log('Express started on 127.0.0.1:3002'); 前端资源位于不同的域 ，但又想要对http://127.0.0.1:3002 的内容进行请求，我们可以搭建一个中间层，来转发请求。对于前端来说是对中间层进行了请求。中间层为server.js代码如下，利用了express + superagent：12345678910111213141516171819/** * 中间层跨域中的：中间层 */var express = require('express');var app = express();app.get('/', function (req, res) &#123; // 使用了superagent来发起请求 var superagent = require('superagent'); // 查询本机ip，这里需要根据实际情况选择get还是post var sreq = superagent.get('http://127.0.0.1:3002/'); sreq.pipe(res); sreq.on('end', function()&#123; console.log('done'); &#125;);&#125;);app.listen(3001);console.log('Express started on 127.0.0.1:3001'); 启动中间层，在浏览器中输入http://127.0.0.1:3001 即可看到返回的正确内容。 以上代码不借助superagent的实现方法如下：12345678910111213141516171819202122var http = require('http');// 创建http服务var app = http.createServer(function (req, res) &#123; // 查询本机ip var sreq = http.request(&#123; host: 'sneezryworks.sinaapp.com', // 目标主机 path: '/ip.php', // 目标路径 method: req.method // 请求方式 &#125;, function(sres)&#123; sres.pipe(res); sres.on('end', function()&#123; console.log('done'); &#125;); &#125;); if (/POST|PUT/i.test(req.method)) &#123; req.pipe(sreq); &#125; else &#123; sreq.end(); &#125;&#125;);app.listen(3001);console.log('Express started on 127.0.0.1:3001'); 5. nginx反向代理利用nginx路由重写，example like this:1234location ^~/proxy/html/&#123; rewrite ^/proxy/html/(.*)$ /$1 break; proxy_pass http://www.b.com/;&#125; ^~/proxy/html/匹配任何以 /proxy/html/开头的地址。 6. window.postMessagepostMessage接收两个参数，一个是想要发送的信息，第二个是要发送至的origin。在接收端，需要监听message事件，并且制定事件源。测试如下： 打开https://www.baidu.com ，开发者模式下，在控制台输入：123window.addEventListener('message','http://iwtofly.cn',function(event) &#123; console.log(event.data);&#125;); 打开http://iwtofly.cn ，开发者模式下，在控制台输入：12var win = window.open('https://www.baidu.com');win.postMessage('Hello, I am iwtofly', 'https://www.baidu.com'); 可以看到，在百度首页的控制台打印出接收到的信息。关于postMessage详细信息，见 https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage 。 参考：https://segmentfault.com/a/1190000000718840http://harttle.com/2015/10/10/cross-origin.htmlhttp://www.cnblogs.com/rainman/archive/2011/02/20/1959325.htmlJSONP：http://www.cnblogs.com/chopper/archive/2012/03/24/2403945.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]}]