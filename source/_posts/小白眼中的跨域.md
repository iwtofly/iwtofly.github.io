---
title: 小白眼中的跨域
date: 2017-02-15 21:02:20
tags: 前端
---
跨域，这个纠结好久的问题，最近终于有些思路了。仿佛预见了自己将要不是哪个懒得只知道用cors中间件的小白啦！

## 什么是跨域

我们来看一下什么是跨域以及同源策略：
>通过XHR实现Ajax通信的的主要限制，来源于跨域安全策略。所谓同源是指，域名，协议，端口相同。默认情况下，XHR对象只能访问与包含它的页面位于同一个域的资源。这种安全策略可以预防某些恶意行为。
简单来说，形如a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。

<!-- more -->
跨域的几种情况下表所示：

|   URL1     |  URL2   | 说明   |  通信否  |
| --------   | -----:  |-----:  | :----:  |
| http://www.a.com/a.js | http://www.a.com/b.js  | 同一域名下|   可    |
| http://www.a.com/lab/a.js | http://www.a.com/script/b.js    |   同一域名不同文件夹  |   可   |
|http://www.a.com:8000/a.js | http://www.a.com/b.js |    同一域名不同端口    |  否  |
|http://www.a.com/a.js | https://www.a.com/b.js | 同一域名不同协议 | 否 |
|http://www.a.com/a.js | http://70.32.92.74/b.js | 域名和域名对应ip | 否 |
| http://www.a.com/a.js | http://script.a.com/b.js | 主域相同，子域不同 | 否 |
|http://www.a.com/a.js | http://a.com/b.js | 同一域名，不同二级域名（同上）| 否（cookie这种情况下也不允许访问）|
| http://www.cnblogs.com/a.js | http://www.a.com/b.js | 不同域名 | 否 |

其中，如果是协议和端口造成的跨域问题前端是无能为力的；而且，在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。

## 如何解决跨域问题
跨域问题的解决办法有很多种,大致可以分为两类：
> * 一类是Hack，比如通过title、navigation、script等对象传递信息，** JSONP **就是一种Hack方式;
> * 另一类是HTML5支持，其中一种是** Access-Control-Allow-Origin **响应头，一个是** window.postMessage **;

#### 1. JSONP
>实现原理：虽然我们不能直接请求异源上的资源，但是在js中如img，script标签却是可以得到其他服务器上的资源的，那么我们就可以通过这样的方式将一段js代码间接地从外部引入。通过script标签向目标源发起一个GET请求，服务器根据请求的参数返回包含js的代码。

JSONP是JSON with Padding的简写，是一个非官方协议，她允许在服务端集成Script Tags返回客户端，通过javascript callback的形式实现跨域访问（注：简单实现形式是这样）。

缺点：JSONP只能实现GET请求。随着现在RESTful的兴起，JSONP显得力不从心了。因为，RESTful不仅有GET，还存在POST、PUT、PATCH、DELETE等等。

下面为index.html的代码：
```html
<!DOCTYPE html>
<html>
<head>
    <title>jsonp test</title>
    <meta charset="utf-8">
</head>
<body>
<script type="text/javascript">
    var url = 'ticker.js';
    function addScriptTag(src) {
        var script = document.createElement('script');
        script.setAttribute('src', src);
        document.body.appendChild(script);
    }
    function callBack(data) {
        console.log(data);
    }
    window.onload = function() {
        addScriptTag(url);
    }
</script>
</body>
</html>
```
其中，ticker.js中的内容如下：
```javascript
callBack(
    {
            name:'iwtofly',
            job: 'FE'
    }
)
```
结果显示如下：
![jsonp-result](/images/jsonp-result.png) 

此外还有很多好玩的地方可以小探索一下，例如google、Flickr等等都提供了JSONP的回调接口，笔者不才最近正在小玩了下Flickr，等稍有成果之后再做呈现。

#### 2. iframe + domain

原理 —— 形如http://a.com/video 与 http://b.a.com/video、http://c.a.com/video 这种** 主域相同，子域不同**的情况，可以通过设置document.domain让它们同域。
限制 —— 同域document提供的是页面间的相互操作，需要载入iframe页面(即，只能通过页面嵌套的方式)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.domain用来得到当前网页的域名，给document.domain属性赋值是有限制的 —— 只能赋成当前的域名或者基础域名。http://b.a.com/ 为当前域名，http://a.com/ 为基础域名。因此，利用document.domain实现跨域前提条件为，这两个域名必须属于同一个基础域名而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。
```javascript
// 当前为http://iwtofly.cn/video
var ifr = document.createElement('iframe');
ifr.src = 'http://www.iwtofly.cn/video'; 
ifr.onload = function(){
    var ifrdoc = ifr.contentDocument || ifr.contentWindow.document;
    ifrdoc.getElementsById("foo").innerHTML);
};

ifr.style.display = 'none';
document.body.appendChild(ifr);
```
假设上述代码所在的URL为http://iwtofly.cn/video ，它对http://www.iwtofly.cn/video 的DOM访问要求后者将document.domain往上设置一级:
```javascript
document.domain = iwtofly.cn;
```
document.domain** 只能从子域设置到主域，往下设置以及往其他域名设置都是不允许的 **




#### 3. cors
>CORS（Cross Origin Resource Sharing, 跨源资源共享）是W3C的一个工作草案，定义了在必须访问跨源资源时浏览器与服务器应该如何进行沟通。其背后的思想，就是定义HTTP头部让浏览器与服务器进行沟通，从而决定请求或相应的成功与否，以便服务器根据这个头部信息来决定是否给予相应。

Origin头部示例：
```bash
Origin: http://iwtofly.cn
```
如果服务器认为这个来源的请求是可以接受的，就在Access-Control-Allow-Origin头部中回发相同的源信息，'*'代表允许一切来源的请求，一般设置为公共资源。
示例：
```bash
Access-Control-Allow-Origin: http://iwtofly.cn 
```
笔者用过这方面的工具有nodejs cors中间件。cors中间件在使用前需要安装cors模块：
```bash
$ npm install cors --save
```
然后，在 index.js 内添加中间件 app.use(cors());
```javascript
var express = require('express');
var app = express();
var cors =require('cors');

app.use(cors()); // 作用于全局的请求
app.get('/table',function (req, res) {
    res.send(data);
})

// 只用于'/table'的GET的写法
// app.get('/table', cors(), function (req, res) {
//     res.send(data);
// });

var server = app.listen(8988, function () {
    var host = server.address().address;
    var port = server.address().port;

    console.log('back server: http://%s:%s', host, port);
})
```
只有使用 cors()中间件才会释放出我们 Api 的访问权限。最好是控制哪些客户端可以进行连接，哪些方法可以使用。最主要的是，必须要在请求的时候加入到头部。在我们这个例子中仅需要设置三个属性： orgin（访问域）、method（访问方法）、alloweHeaders（请求头）。
```bash
var express = require('express');  
var cors = require('cors');  
var app = express();

app.use(cors({  
  origin: ['http://localhost:3001'],
  methods: ['GET', 'POST'],
  alloweHeaders: ['Conten-Type', 'Authorization']
}));

app.get('/', function(req, res) {  
  res.json({status: 'My Api is alive!'});
});

app.listen(3000, function() {  
  console.log('My Api is running...');
});

module.exports = app;
```

#### 4. 中间层代理
跨域问题的核心是不同源访问，因此，如果我们转换为同源请求，就不存在这个问题啦。
通过搭建中间层，可以是java，也可以是node.js，通过将服务端的请求进行转发，换句话说，就是dispatcher了一层，那么前端请求的地址，就被转发了，所以很好的解决跨域问题。
缺点：如果对性能有考量的产品，就需要慎重选择这个方案，因为多了一层中间转发，不管是网络开销，还是性能负载都是有一定的影响。

做了一个小测试，假设以下为server2.js,我们真正要请求的后端，运行在3002端口：
```javascript
/**
 * 中间层跨域中的：server后端
 */
var express = require('express');
var app = express();

app.get('/', function (req, res) {
    res.json({
        name: 'iwtofly',
        job: 'FE'
    })
});
app.listen(3002);
console.log('Express started on 127.0.0.1:3002');
```
前端资源位于不同的域 ，但又想要对http://127.0.0.1:3002 的内容进行请求，我们可以搭建一个中间层，来转发请求。对于前端来说是对中间层进行了请求。中间层为server.js代码如下，利用了express + superagent：
```javascript
/**
 * 中间层跨域中的：中间层
 */

var express = require('express');
var app = express();

app.get('/', function (req, res) {
    // 使用了superagent来发起请求
    var superagent = require('superagent');
    // 查询本机ip，这里需要根据实际情况选择get还是post
    var sreq = superagent.get('http://127.0.0.1:3002/');
    sreq.pipe(res);
    sreq.on('end', function(){
        console.log('done');
    });
});
app.listen(3001);
console.log('Express started on 127.0.0.1:3001');
```
启动中间层，在浏览器中输入http://127.0.0.1:3001 即可看到返回的正确内容。

以上代码不借助superagent的实现方法如下：
```javascript
var http = require('http');
// 创建http服务
var app = http.createServer(function (req, res) {
    // 查询本机ip
    var sreq = http.request({
        host:     'sneezryworks.sinaapp.com', // 目标主机
        path:     '/ip.php', // 目标路径
        method:   req.method // 请求方式
    }, function(sres){
        sres.pipe(res);
        sres.on('end', function(){
            console.log('done');
        });
    });
    if (/POST|PUT/i.test(req.method)) {
        req.pipe(sreq);
    } else {
        sreq.end();
    }
});
app.listen(3001);
console.log('Express started on 127.0.0.1:3001');
```

#### 5. nginx反向代理
利用nginx路由重写，example like this:
```
location ^~/proxy/html/{
    rewrite ^/proxy/html/(.*)$ /$1 break;
    proxy_pass http://www.b.com/;
}
```
^~/proxy/html/匹配任何以 /proxy/html/开头的地址。

#### 6. window.postMessage
postMessage接收两个参数，一个是想要发送的信息，第二个是要发送至的origin。在接收端，需要监听message事件，并且制定事件源。测试如下：

打开https://www.baidu.com ，开发者模式下，在控制台输入：
```javascript
window.addEventListener('message','http://iwtofly.cn',function(event) {
    console.log(event.data);
});
```

打开http://iwtofly.cn ，开发者模式下，在控制台输入：
```javascript
var win = window.open('https://www.baidu.com');
win.postMessage('Hello, I am iwtofly', 'https://www.baidu.com'); 
```
可以看到，在百度首页的控制台打印出接收到的信息。关于postMessage详细信息，见 https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage 。


#### 参考：
https://segmentfault.com/a/1190000000718840 
http://harttle.com/2015/10/10/cross-origin.html
http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html
JSONP：
http://www.cnblogs.com/chopper/archive/2012/03/24/2403945.html
